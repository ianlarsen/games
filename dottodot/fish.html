<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Dot‑to‑Dot: Ocean Fun</title>
  <style>
    /* =======================
       Global Layout & Theming
       ======================= */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    :root {
      /* The board is a perfect square that fits 80% of the viewport height,
         but never exceeds 95% of the viewport width. JS will override this
         with a pixel value for older/mobile browsers. */
      --board-size: min(80svh, 95vw);
    }

    body {
      margin: 0;
      background: #e0f7fa; /* Light cyan for an underwater feel */
      color: #111;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.3;
      -webkit-font-smoothing: antialiased;
    }

    .page {
      min-height: 100svh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      padding: clamp(8px, 2.5vw, 18px);
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .topbar h1 { font-size: clamp(18px, 3.8vw, 28px); margin: 0; }
    .topbar .status { display: inline-flex; gap: 10px; align-items: center; font-weight: 500; }
    #resetBtn {
      appearance: none;
      border: 1px solid #222;
      background: #fff;
      padding: 6px 10px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #resetBtn:hover {
        background-color: #f0f0f0;
    }

    /* =======================
       Board (square container)
       ======================= */
    .board-wrap {
      position: relative;
      margin: 0 auto;
      width: var(--board-size);
      height: var(--board-size); /* keep square */
      border: 2px solid #111;
      border-radius: 16px;
      overflow: hidden;
      background: #fff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    /* Completion image sits underneath and fades in on win */
    #completedImage {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      transition: opacity 800ms ease;
      pointer-events: none;
    }
    #completedImage.revealed { opacity: 1; }

    /* SVG board fills container */
    #board { position: absolute; inset: 0; width: 100%; height: 100%; }
    #path {
      stroke: #111;
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
    }

    /* Dots & labels */
    .dot .visual { fill: #111; stroke: #111; stroke-width: 0.5; transition: fill 0.2s; }
    .dot .hit { fill: transparent; pointer-events: all; cursor: pointer; }
    .dot.active .ring { stroke: #007bff; stroke-width: 2.5; fill: none; r: 16; transition: r 0.3s ease-out; }
    .dot.active .visual { fill: #007bff; }
    
    .dot text {
      font-size: 20px; /* SVG units; scales with viewBox */
      fill: #111;
      paint-order: stroke;
      stroke: #fff;
      stroke-width: 4;
      font-weight: 700;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none; 
    }
    .dot.active text {
        font-size: 24px;
        fill: #007bff;
    }

    /* Feedback */
    .dot.wrong .visual { fill: #b00020; }
    @keyframes nudge {
      0% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      50% { transform: translateX(4px); }
      75% { transform: translateX(-3px); }
      100% { transform: translateX(0); }
    }
    .dot.wrong { animation: nudge 180ms ease; }

    .hint {
      text-align: center;
      font-size: clamp(12px, 2.8vw, 14px);
      color: #333;
    }
  </style>
</head>
<body>
  <main class="page">
    <header class="topbar">
      <h1>Dot‑to‑Dot: Ocean Fun</h1>
      <div class="status">
        <span id="progress">1 / 95</span>
        <button id="resetBtn" aria-label="Reset level">Reset</button>
      </div>
    </header>

    <section class="board-wrap">
      <!-- The user's uploaded fish.jpg will be used here -->
      <img id="completedImage" src="fish.jpg" alt="An underwater scene with a clownfish, seahorse, and crab" />
      <svg id="board" viewBox="0 0 1000 1000" role="img" aria-label="Dot to dot board">
        <defs>
          <filter id="halo" x="-50%" y="-50%" width="200%" height="200%">
            <feMorphology in="SourceAlpha" operator="dilate" radius="3" result="HALO" />
            <feGaussianBlur in="HALO" stdDeviation="2" result="BLUR" />
            <feMerge>
              <feMergeNode in="BLUR" />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
        <polyline id="path" points="" />
        <g id="dots"></g>
      </svg>
    </section>

    <footer class="hint">Tap the dots in order: 1 → 95. When you're done, the full ocean scene will appear!</footer>
  </main>

  <script>
    /* Dot-to-Dot Ocean Fun */

    const LEVEL = {
      imageSrc: "fish.jpg",
      viewBox: [1000, 1000],
      dots: [
        // Clownfish (1-50)
        { x: 428, y: 350 }, // 1 - Top fin start
        { x: 505, y: 332 }, // 2
        { x: 577, y: 343 }, // 3
        { x: 620, y: 367 }, // 4
        { x: 650, y: 405 }, // 5 - Back of body
        { x: 690, y: 450 }, // 6
        { x: 720, y: 500 }, // 7
        { x: 730, y: 550 }, // 8 - Tail fin top
        { x: 770, y: 590 }, // 9
        { x: 805, y: 620 }, // 10
        { x: 830, y: 670 }, // 11
        { x: 820, y: 710 }, // 12
        { x: 785, y: 730 }, // 13
        { x: 745, y: 720 }, // 14
        { x: 720, y: 680 }, // 15
        { x: 700, y: 630 }, // 16 - Tail fin bottom
        { x: 670, y: 610 }, // 17 - Bottom of body
        { x: 630, y: 620 }, // 18
        { x: 590, y: 650 }, // 19
        { x: 550, y: 690 }, // 20 - Bottom fin start
        { x: 570, y: 730 }, // 21
        { x: 600, y: 760 }, // 22
        { x: 580, y: 785 }, // 23
        { x: 540, y: 770 }, // 24
        { x: 520, y: 730 }, // 25
        { x: 510, y: 680 }, // 26 - Back to body
        { x: 470, y: 670 }, // 27
        { x: 430, y: 660 }, // 28
        { x: 390, y: 650 }, // 29 - Chin
        { x: 340, y: 630 }, // 30
        { x: 300, y: 590 }, // 31 - Mouth
        { x: 290, y: 550 }, // 32
        { x: 310, y: 510 }, // 33 - Nose
        { x: 350, y: 480 }, // 34
        { x: 400, y: 460 }, // 35 - Top of head
        { x: 450, y: 450 }, // 36
        { x: 480, y: 470 }, // 37 - Pectoral fin (side)
        { x: 520, y: 490 }, // 38
        { x: 555, y: 530 }, // 39
        { x: 570, y: 570 }, // 40
        { x: 550, y: 590 }, // 41
        { x: 520, y: 580 }, // 42
        { x: 490, y: 550 }, // 43
        { x: 475, y: 510 }, // 44 - Back to body
        { x: 720, y: 625 }, // 45 - Extra tail detail
        { x: 620, y: 700 }, // 46
        { x: 520, y: 640 }, // 47
        { x: 420, y: 610 }, // 48
        { x: 350, y: 560 }, // 49
        { x: 470, y: 400 }, // 50
        // Seahorse (51-75)
        { x: 195, y: 584 }, // 51 - Snout
        { x: 160, y: 600 }, // 52
        { x: 135, y: 630 }, // 53 - Head
        { x: 138, y: 670 }, // 54
        { x: 160, y: 700 }, // 55 - Neck
        { x: 180, y: 730 }, // 56 - Belly
        { x: 185, y: 770 }, // 57
        { x: 170, y: 810 }, // 58
        { x: 150, y: 840 }, // 59
        { x: 120, y: 860 }, // 60 - Tail curl
        { x: 100, y: 840 }, // 61
        { x: 105, y: 810 }, // 62
        { x: 130, y: 800 }, // 63
        { x: 150, y: 780 }, // 64
        { x: 160, y: 750 }, // 65
        { x: 155, y: 720 }, // 66 - Back
        { x: 170, y: 680 }, // 67
        { x: 190, y: 650 }, // 68
        { x: 210, y: 630 }, // 69
        { x: 230, y: 635 }, // 70 - Back fin
        { x: 245, y: 660 }, // 71
        { x: 240, y: 690 }, // 72
        { x: 225, y: 720 }, // 73
        { x: 210, y: 700 }, // 74
        { x: 195, y: 670 }, // 75
        // Crab (76-95)
        { x: 787, y: 884 }, // 76 - Left claw top
        { x: 750, y: 890 }, // 77
        { x: 755, y: 920 }, // 78
        { x: 790, y: 915 }, // 79 - Left claw bottom
        { x: 815, y: 890 }, // 80 - Body
        { x: 850, y: 875 }, // 81
        { x: 890, y: 880 }, // 82
        { x: 920, y: 895 }, // 83
        { x: 945, y: 880 }, // 84 - Right claw top
        { x: 975, y: 870 }, // 85
        { x: 970, y: 900 }, // 86
        { x: 940, y: 910 }, // 87 - Right claw bottom
        { x: 915, y: 898 }, // 88
        { x: 890, y: 910 }, // 89 - Bottom of body
        { x: 850, y: 925 }, // 90
        { x: 810, y: 920 }, // 91
        { x: 790, y: 940 }, // 92 - Left leg
        { x: 830, y: 945 }, // 93
        { x: 880, y: 940 }, // 94
        { x: 920, y: 930 }, // 95 - Right leg
      ],
    };

    let state = {
      expected: 1,
      points: [],
      poly: null,
      audioCtx: null,
      started: false,
      finished: false,
    };

    document.addEventListener("DOMContentLoaded", init);

    function init() {
      const svg = document.getElementById("board");
      svg.setAttribute("viewBox", "0 0 1000 1000");
      setBoardTo80vh();
      window.addEventListener("resize", setBoardTo80vh);
      window.addEventListener("orientationchange", setBoardTo80vh);

      const path = document.getElementById("path");
      state.poly = path;
      updateProgress();

      renderDots();
      setActiveDot(1);

      document.getElementById("resetBtn").addEventListener("click", resetGame, { passive: true });
    }

    function renderDots() {
      const dotsGroup = document.getElementById("dots");
      while (dotsGroup.firstChild) dotsGroup.removeChild(dotsGroup.firstChild);
      
      LEVEL.dots.forEach((pt, i) => {
        const g = el("g", { class: "dot", "data-index": i + 1 });
        const ring = el("circle", { class: "ring", cx: pt.x, cy: pt.y, r: 0 });
        const visual = el("circle", { class: "visual", cx: pt.x, cy: pt.y, r: 7 });
        const hit = el("circle", { class: "hit", cx: pt.x, cy: pt.y, r: 25 });
        
        let labelX = pt.x;
        let labelY = pt.y - 22; // Default above
        let anchor = "middle";

        if (pt.y < 50) labelY = pt.y + 26; // If near top, move below
        if (pt.x > 950) { labelX = pt.x - 20; anchor = "end"; } // If near right, move left
        if (pt.x < 50) { labelX = pt.x + 20; anchor = "start"; } // If near left, move right

        const label = el("text", { x: labelX, y: labelY, "text-anchor": anchor, "dominant-baseline": "central" });
        label.textContent = i + 1;
        
        g.appendChild(ring);
        g.appendChild(visual);
        g.appendChild(hit);
        g.appendChild(label);
        dotsGroup.appendChild(g);
        
        g.addEventListener("pointerdown", onDotPointer);
      });
    }

    function onDotPointer(e) {
      e.preventDefault();
      const g = e.currentTarget;
      const index = Number(g.getAttribute("data-index"));
      ensureAudio();

      if (state.finished) return;

      if (index === state.expected) {
        goodTap(index);
      } else {
        badTap(g);
      }
    }

    function goodTap(index) {
      const pt = LEVEL.dots[index - 1];
      const dotElement = document.querySelector(`.dot[data-index="${index}"]`);
      if(dotElement) {
        dotElement.style.visibility = 'hidden';
      }

      if (!state.started) {
        state.started = true;
        state.points = [`${pt.x},${pt.y}`];
      } else {
        state.points.push(`${pt.x},${pt.y}`);
        state.poly.setAttribute("points", state.points.join(" "));
      }

      ding();

      state.expected++;
      updateProgress();

      clearActiveDot();
      if (state.expected <= LEVEL.dots.length) {
        setActiveDot(state.expected);
      } else {
        win();
      }
    }

    function badTap(g) {
      buzz();
      if ("vibrate" in navigator) navigator.vibrate(25);
      g.classList.add("wrong");
      setTimeout(() => g.classList.remove("wrong"), 200);
    }

    function win() {
      state.finished = true;
      chime();
      document.getElementById("completedImage").classList.add("revealed");
    }

    function resetGame() {
      state = { 
        expected: 1, 
        points: [], 
        poly: state.poly, 
        audioCtx: state.audioCtx, 
        started: false, 
        finished: false 
      };
      state.poly.setAttribute("points", "");
      document.getElementById("completedImage").classList.remove("revealed");
      document.querySelectorAll(".dot").forEach((g) => {
          g.classList.remove("wrong", "active");
          g.style.visibility = 'visible';
      });
      setActiveDot(1);
      updateProgress();
    }

    function ensureAudio() {
      if (!state.audioCtx) {
        try {
          state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
          console.error("Web Audio API is not supported in this browser.");
        }
      }
    }

    function tone({ freq = 440, type = "sine", duration = 0.1, gain = 0.06, when = 0 }) {
      if (!state.audioCtx) return;
      const ctx = state.audioCtx;
      const t0 = ctx.currentTime + when;
      const osc = ctx.createOscillator();
      const amp = ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);
      amp.gain.setValueAtTime(gain, t0);
      amp.gain.exponentialRampToValueAtTime(0.0001, t0 + duration);
      osc.connect(amp).connect(ctx.destination);
      osc.start(t0);
      osc.stop(t0 + duration + 0.02);
    }

    function ding() {
      tone({ freq: 880, duration: 0.07, gain: 0.055 });
      tone({ freq: 1320, duration: 0.09, gain: 0.05, when: 0.06 });
    }

    function buzz() {
      tone({ freq: 220, type: "sawtooth", duration: 0.08, gain: 0.06 });
      tone({ freq: 160, type: "square", duration: 0.08, gain: 0.05, when: 0.06 });
    }

    function chime() {
      const freqs = [523.25, 659.25, 783.99, 1046.5];
      freqs.forEach((f, i) => tone({ freq: f, duration: 0.18, gain: 0.06, when: i * 0.12 }));
    }

    function setActiveDot(n) {
      const g = document.querySelector(`.dot[data-index="${n}"]`);
      if (!g) return;
      if (g.parentNode) g.parentNode.appendChild(g); // Bring to front
      g.classList.add("active");
      const ring = g.querySelector(".ring");
      if (ring) ring.setAttribute("r", "16");
      const hit = g.querySelector(".hit");
      if (hit) hit.setAttribute("r", "32");
    }

    function clearActiveDot() {
      const g = document.querySelector(`.dot.active`);
      if (!g) return;
      g.classList.remove("active");
      const ring = g.querySelector(".ring");
      if (ring) ring.setAttribute("r", "0");
      const hit = g.querySelector(".hit");
      if (hit) hit.setAttribute("r", "25");
    }

    function updateProgress() {
      const total = LEVEL.dots.length;
      const current = Math.min(state.expected, total);
      const el = document.getElementById("progress");
      if (el) el.textContent = `${current} / ${total}`;
    }

    function el(tag, attrs = {}) {
      const node = document.createElementNS("http://www.w3.org/2000/svg", tag);
      Object.entries(attrs).forEach(([k, v]) => node.setAttribute(k, String(v)));
      return node;
    }

    function setBoardTo80vh() {
      const visualH = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
      const H = Math.max(0, visualH) * 0.8;
      const W = window.innerWidth * 0.95;
      const size = Math.min(H, W);
      document.documentElement.style.setProperty("--board-size", size + "px");
    }
  </script>
</body>
</html>

