<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Robot Bunny Platformer ‚Äî Moon Edition</title>
<style>
  :root {
    --bg-deep: #000000;
    --bg-halo: #0a0f18;
  }
  html, body { height: 100%; margin: 0; background: var(--bg-deep); color: #e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
  #wrap { display: grid; place-items: center; height: 100%; }
  canvas {
    background: radial-gradient(1000px 600px at 50% -200px, var(--bg-halo), var(--bg-deep) 55%);
    width: min(100vw, 960px);
    height: min(62vh, 560px);
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0,0,0,.45), inset 0 0 80px rgba(123,226,255,0.03);
  }
  .hud {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 16px; font-weight: 650; letter-spacing: .2px;
    text-shadow: 0 0 8px rgba(123,226,255,.15);
  }
  .hint { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); opacity: .8; font-size: 14px; color: #9fb1cc; }
  .badge { position: fixed; top: 10px; right: 14px; font-size: 12px; color: #9fb1cc; opacity: .8; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="560" aria-label="Robot Bunny Platformer ‚Äî Moon Edition"></canvas>
</div>
<div class="hud">
  <div id="level">Level: 1</div>
  <div id="lives">Lives: 3</div>
  <div id="score">Score: 0</div>
  <div id="coins">Coins: 0</div>
</div>
<div class="hint">Move: ‚Üê‚Üí ‚Ä¢ Jump: Space/‚Üë ‚Ä¢ Shoot: X/Z ‚Ä¢ Pause: ESC</div>
<div class="badge">Platformer Edition</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function fit() {
    const maxW = Math.min(window.innerWidth, 960);
    const maxH = Math.min(window.innerHeight * 0.62, 560);
    const ar = canvas.width / canvas.height;
    let w = maxW, h = w / ar;
    if (h > maxH) { h = maxH; w = h * ar; }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', fit); fit();

  const GROUND_Y = canvas.height - 80;
  const gravity = 2200;
  const jumpVel = -950;
  const moveSpeed = 250;
  const maxVelX = 350;

  let time = 0;
  let score = 0;
  let coins = Number(localStorage.getItem('rb_moon_coins') || 0);
  let sessionCoins = 0;
  let lives = 3;
  let currentLevel = 1;
  let gameOver = false;
  let levelComplete = false;
  let paused = false;
  let pauseTab = 'info';
  let camera = { x: 0, y: 0 };

  const player = {
    x: 100, y: GROUND_Y - 72, w: 48, h: 64,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    shootCooldown: 0,
    invincible: false,
    invincibleTimer: 0,
    animState: 'idle', // idle, walk, jump
    animFrame: 0,
    animTimer: 0
  };

  const keys = {};
  let wantShoot = false;

  const lasers = [];
  const enemies = [];
  const platforms = [];
  const particles = [];
  const coins_objs = [];
  let levelGoal = null;

  // Parallax background layers
  const bgLayers = [
    { elements: [], speed: 0.1, color: '#0a0f18' }, // Far stars
    { elements: [], speed: 0.3, color: '#1a2530' }, // Mid stars
    { elements: [], speed: 0.5, color: '#2a3540' }  // Close stars
  ];

  let shakeX = 0, shakeY = 0, shakeIntensity = 0;

  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();
  let soundEnabled = true;
  let musicNodes = [];
  let musicPlaying = false;
  let currentMusicLevel = 0;

  // Music system - 3 distinct tracks
  const musicTracks = [
    { // Level 1 - Upbeat exploration
      tempo: 500,
      melody: [
        { note: 392, duration: 0.3 }, // G
        { note: 440, duration: 0.3 }, // A
        { note: 494, duration: 0.3 }, // B
        { note: 523, duration: 0.3 }, // C
        { note: 494, duration: 0.3 }, // B
        { note: 440, duration: 0.3 }, // A
        { note: 392, duration: 0.6 }, // G
        { note: 330, duration: 0.6 }  // E
      ],
      bass: [330, 392, 294, 349]
    },
    { // Level 2 - Action/intensity
      tempo: 400,
      melody: [
        { note: 523, duration: 0.2 }, // C
        { note: 659, duration: 0.2 }, // E
        { note: 784, duration: 0.2 }, // G
        { note: 659, duration: 0.2 }, // E
        { note: 698, duration: 0.4 }, // F
        { note: 659, duration: 0.2 }, // E
        { note: 587, duration: 0.2 }, // D
        { note: 523, duration: 0.4 }  // C
      ],
      bass: [262, 330, 349, 294]
    },
    { // Level 3 - Epic/triumphant
      tempo: 450,
      melody: [
        { note: 440, duration: 0.4 }, // A
        { note: 523, duration: 0.2 }, // C
        { note: 587, duration: 0.2 }, // D
        { note: 659, duration: 0.4 }, // E
        { note: 587, duration: 0.2 }, // D
        { note: 523, duration: 0.2 }, // C
        { note: 494, duration: 0.4 }, // B
        { note: 440, duration: 0.4 }  // A
      ],
      bass: [220, 262, 294, 330]
    }
  ];

  function startMusic(levelNum = 1) {
    stopMusic();
    if (!soundEnabled) return;
    musicPlaying = true;
    currentMusicLevel = (levelNum - 1) % musicTracks.length;

    const track = musicTracks[currentMusicLevel];
    let melodyIndex = 0;
    let bassIndex = 0;

    function playMelodyNote() {
      if (!musicPlaying || !soundEnabled) return;

      const noteData = track.melody[melodyIndex % track.melody.length];
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.value = noteData.note;
      gain.gain.value = 0.04;

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.04, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + noteData.duration);

      osc.start(now);
      osc.stop(now + noteData.duration);

      musicNodes.push(osc);
      melodyIndex++;

      setTimeout(playMelodyNote, noteData.duration * 1000);
    }

    function playBassNote() {
      if (!musicPlaying || !soundEnabled) return;

      const note = track.bass[bassIndex % track.bass.length];
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'triangle';
      osc.frequency.value = note;
      gain.gain.value = 0.03;

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      const duration = track.tempo / 1000;
      osc.start(now);
      osc.stop(now + duration);

      musicNodes.push(osc);
      bassIndex++;

      setTimeout(playBassNote, track.tempo);
    }

    playMelodyNote();
    playBassNote();
  }

  function stopMusic() {
    musicPlaying = false;
    for (const node of musicNodes) {
      try { node.stop(); } catch(e) {}
    }
    musicNodes = [];
  }

  const achievements = [
    { id: 'first_coin', name: 'First Coin', desc: 'Collect your first coin', check: () => sessionCoins >= 1, icon: 'ü™ô' },
    { id: 'coin_collector', name: 'Coin Collector', desc: 'Collect 50 coins total', check: () => coins + sessionCoins >= 50, icon: 'üí∞' },
    { id: 'first_enemy', name: 'Enemy Defeated', desc: 'Defeat your first enemy', check: () => (stats.enemiesDefeated || 0) >= 1, icon: '‚öîÔ∏è' },
    { id: 'level_1', name: 'Level Complete', desc: 'Complete level 1', check: () => currentLevel > 1, icon: 'üèÅ' },
    { id: 'marksman', name: 'Marksman', desc: 'Hit 10 enemies with lasers', check: () => (stats.laserHits || 0) >= 10, icon: 'üéØ' },
    { id: 'stomper', name: 'Stomper', desc: 'Stomp 10 enemies', check: () => (stats.stomps || 0) >= 10, icon: 'üëü' },
  ];
  const unlockedAchievements = JSON.parse(localStorage.getItem('rb_moon_achievements') || '[]');
  const achievementNotifications = [];

  const stats = JSON.parse(localStorage.getItem('rb_moon_stats') || '{"enemiesDefeated": 0, "laserHits": 0, "stomps": 0}');

  const skins = [
    { id: 'default', name: 'Classic', cost: 0, body: '#aeb7c4', shadow: '#738096', accent: '#7be2ff' },
    { id: 'gold', name: 'Golden', cost: 50, body: '#FFD700', shadow: '#DAA520', accent: '#FFF8DC' },
    { id: 'red', name: 'Crimson', cost: 75, body: '#DC143C', shadow: '#8B0000', accent: '#FFB6C1' },
    { id: 'green', name: 'Emerald', cost: 100, body: '#50C878', shadow: '#2E8B57', accent: '#98FB98' },
    { id: 'purple', name: 'Royal', cost: 125, body: '#9370DB', shadow: '#663399', accent: '#E6E6FA' },
    { id: 'cyan', name: 'Crystal', cost: 150, body: '#00CED1', shadow: '#008B8B', accent: '#AFEEEE' },
    { id: 'rainbow', name: 'Rainbow', cost: 250, body: 'rainbow', shadow: '#663399', accent: '#FFD700' }
  ];
  let currentSkin = localStorage.getItem('rb_moon_skin') || 'default';
  const unlockedSkins = JSON.parse(localStorage.getItem('rb_moon_unlocked_skins') || '["default"]');

  function getSkin() {
    return skins.find(s => s.id === currentSkin) || skins[0];
  }

  function playSound(type) {
    if (!soundEnabled) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    switch(type) {
      case 'jump':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
      case 'shoot':
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now); osc.stop(now + 0.08);
        break;
      case 'coin':
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
        break;
      case 'hit':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
        break;
      case 'stomp':
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
      case 'levelComplete':
        osc.frequency.setValueAtTime(523, now);
        osc.frequency.setValueAtTime(659, now + 0.1);
        osc.frequency.setValueAtTime(784, now + 0.2);
        osc.frequency.setValueAtTime(1047, now + 0.3);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now); osc.stop(now + 0.5);
        break;
    }
  }

  function checkAchievements() {
    for (const ach of achievements) {
      if (!unlockedAchievements.includes(ach.id) && ach.check()) {
        unlockedAchievements.push(ach.id);
        localStorage.setItem('rb_moon_achievements', JSON.stringify(unlockedAchievements));
        achievementNotifications.push({ ...ach, time: 0, duration: 3.0 });
      }
    }
  }

  function buySkin(skinId) {
    const skin = skins.find(s => s.id === skinId);
    if (!skin || unlockedSkins.includes(skinId) || coins < skin.cost) return;
    coins -= skin.cost;
    unlockedSkins.push(skinId);
    localStorage.setItem('rb_moon_coins', coins);
    localStorage.setItem('rb_moon_unlocked_skins', JSON.stringify(unlockedSkins));
    currentSkin = skinId;
    localStorage.setItem('rb_moon_skin', currentSkin);
    playSound('coin');
  }

  window.addEventListener('keydown', (e) => {
    if (['Space','ArrowUp','ArrowLeft','ArrowRight','Escape','KeyP','KeyM','KeyX','KeyZ','Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Enter'].includes(e.code)) e.preventDefault();

    if ((e.code === 'Escape' || e.code === 'KeyP') && !gameOver && !levelComplete) {
      paused = !paused;
      if (!paused) pauseTab = 'info';
      if (paused) stopMusic();
      else startMusic(currentLevel);
      return;
    }

    if (e.code === 'KeyM') {
      soundEnabled = !soundEnabled;
      if (!soundEnabled) stopMusic();
      else if (!paused && !gameOver) startMusic(currentLevel);
      return;
    }

    if (paused) {
      if (e.code === 'ArrowLeft') pauseTab = 'info';
      if (e.code === 'ArrowRight') pauseTab = 'shop';
      if (pauseTab === 'shop' && e.code.startsWith('Digit')) {
        const num = parseInt(e.code.replace('Digit', '')) - 1;
        if (num >= 0 && num < skins.length) {
          const skin = skins[num];
          if (unlockedSkins.includes(skin.id)) {
            currentSkin = skin.id;
            localStorage.setItem('rb_moon_skin', currentSkin);
            playSound('coin');
          } else {
            buySkin(skin.id);
          }
        }
      }
      return;
    }

    if (gameOver || levelComplete) {
      if (e.code === 'Enter') {
        if (gameOver) reset();
        else if (levelComplete) nextLevel();
      }
      return;
    }

    keys[e.code] = true;
    if (e.code === 'KeyX' || e.code === 'KeyZ') wantShoot = true;
  });

  window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });

  function rand(a, b) { return a + Math.random() * (b - a); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function createParticle(x, y, color, count = 8) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + rand(-0.3, 0.3);
      const speed = rand(100, 250);
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - rand(50, 150),
        life: 1.0,
        decay: rand(1.5, 2.5),
        size: rand(3, 7),
        color
      });
    }
  }

  function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
  }

  function roundRect(x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Initialize parallax background
  function initBackground() {
    for (const layer of bgLayers) {
      layer.elements = [];
      const count = layer.speed < 0.3 ? 80 : (layer.speed < 0.5 ? 50 : 30);
      for (let i = 0; i < count; i++) {
        layer.elements.push({
          x: rand(0, 4000),
          y: rand(0, GROUND_Y - 50),
          size: layer.speed < 0.3 ? rand(1, 2) : (layer.speed < 0.5 ? rand(2, 3) : rand(3, 4)),
          twinkle: rand(0, Math.PI * 2),
          twinkleSpeed: rand(1, 3)
        });
      }
    }
  }

  function loadLevel(levelNum) {
    platforms.length = 0;
    enemies.length = 0;
    coins_objs.length = 0;
    lasers.length = 0;
    particles.length = 0;

    player.x = 100;
    player.y = GROUND_Y - player.h - 20;
    player.vx = 0;
    player.vy = 0;
    player.invincible = false;
    player.invincibleTimer = 0;
    player.animState = 'idle';
    player.animFrame = 0;
    camera.x = 0;
    camera.y = 0;

    platforms.push({ x: 0, y: GROUND_Y + 40, w: 5000, h: 200, type: 'ground' });

    if (levelNum === 1) {
      // BRANCHING PATH: Upper route (harder) and lower route (easier)

      // Lower path
      platforms.push({ x: 300, y: GROUND_Y - 80, w: 150, h: 20, type: 'platform' });
      platforms.push({ x: 550, y: GROUND_Y - 80, w: 150, h: 20, type: 'platform' });

      // Upper path (more coins!)
      platforms.push({ x: 320, y: GROUND_Y - 200, w: 120, h: 20, type: 'platform' });
      platforms.push({ x: 520, y: GROUND_Y - 250, w: 100, h: 20, type: 'platform' });
      platforms.push({ x: 700, y: GROUND_Y - 200, w: 120, h: 20, type: 'platform' });

      // Rejoining platform
      platforms.push({ x: 900, y: GROUND_Y - 120, w: 150, h: 20, type: 'platform' });

      // Enemies
      enemies.push({ x: 400, y: GROUND_Y - 30, w: 40, h: 30, type: 'hopper', vx: 50, vy: 0, health: 1, dir: 1, jumpTimer: 0, animTimer: 0 });
      enemies.push({ x: 800, y: GROUND_Y - 30, w: 35, h: 35, type: 'walker', vx: 80, health: 1, dir: 1, rotateAngle: 0 });

      // Coins - more on upper path
      for (let i = 0; i < 3; i++) {
        coins_objs.push({ x: 350 + i * 40, y: GROUND_Y - 260, size: 14, sparkleT: rand(0, Math.PI * 2) });
      }
      for (let i = 0; i < 2; i++) {
        coins_objs.push({ x: 400 + i * 50, y: GROUND_Y - 120, size: 14, sparkleT: rand(0, Math.PI * 2) });
      }

      levelGoal = { x: 1300, y: GROUND_Y - 80, w: 60, h: 80 };

    } else if (levelNum === 2) {
      // BRANCHING PATH: Middle route with secrets

      // Main path
      platforms.push({ x: 200, y: GROUND_Y - 100, w: 120, h: 20, type: 'platform' });
      platforms.push({ x: 400, y: GROUND_Y - 150, w: 100, h: 20, type: 'platform' });

      // Secret upper area
      platforms.push({ x: 350, y: GROUND_Y - 280, w: 80, h: 20, type: 'platform' });
      platforms.push({ x: 500, y: GROUND_Y - 300, w: 80, h: 20, type: 'platform' });

      // Lower safer route
      platforms.push({ x: 600, y: GROUND_Y - 80, w: 150, h: 20, type: 'platform' });

      // Challenge area
      platforms.push({ x: 850, y: GROUND_Y - 180, w: 80, h: 20, type: 'platform' });
      platforms.push({ x: 1000, y: GROUND_Y - 220, w: 100, h: 20, type: 'platform' });
      platforms.push({ x: 1180, y: GROUND_Y - 160, w: 120, h: 20, type: 'platform' });

      // More enemies
      enemies.push({ x: 300, y: GROUND_Y - 30, w: 40, h: 30, type: 'hopper', vx: 50, vy: 0, health: 1, dir: 1, jumpTimer: 0, animTimer: 0 });
      enemies.push({ x: 650, y: GROUND_Y - 30, w: 40, h: 30, type: 'hopper', vx: 50, vy: 0, health: 1, dir: -1, jumpTimer: 0, animTimer: 0 });
      enemies.push({ x: 500, y: GROUND_Y - 30, w: 35, h: 35, type: 'walker', vx: 80, health: 1, dir: 1, rotateAngle: 0 });
      enemies.push({ x: 900, y: GROUND_Y - 30, w: 35, h: 35, type: 'walker', vx: 80, health: 1, dir: -1, rotateAngle: 0 });
      enemies.push({ x: 700, y: GROUND_Y - 220, w: 45, h: 25, type: 'flyer', vx: 100, vy: 0, health: 1, dir: 1, bobT: 0, flapTimer: 0 });

      // Secret coins
      for (let i = 0; i < 3; i++) {
        coins_objs.push({ x: 380 + i * 50, y: GROUND_Y - 330, size: 14, sparkleT: rand(0, Math.PI * 2) });
      }
      for (let i = 0; i < 6; i++) {
        coins_objs.push({ x: 300 + i * 100, y: GROUND_Y - 190, size: 14, sparkleT: rand(0, Math.PI * 2) });
      }

      levelGoal = { x: 1500, y: GROUND_Y - 80, w: 60, h: 80 };

    } else {
      // Level 3+ - Complex branching

      platforms.push({ x: 150, y: GROUND_Y - 100, w: 100, h: 20, type: 'platform' });

      // Three paths: high, middle, low
      // High path (dangerous, best rewards)
      platforms.push({ x: 300, y: GROUND_Y - 280, w: 80, h: 20, type: 'platform' });
      platforms.push({ x: 450, y: GROUND_Y - 320, w: 80, h: 20, type: 'platform' });
      platforms.push({ x: 600, y: GROUND_Y - 360, w: 100, h: 20, type: 'platform' });

      // Middle path
      platforms.push({ x: 350, y: GROUND_Y - 180, w: 100, h: 20, type: 'platform' });
      platforms.push({ x: 550, y: GROUND_Y - 200, w: 100, h: 20, type: 'platform' });
      platforms.push({ x: 750, y: GROUND_Y - 180, w: 100, h: 20, type: 'platform' });

      // Low path (safest)
      platforms.push({ x: 400, y: GROUND_Y - 80, w: 150, h: 20, type: 'platform' });
      platforms.push({ x: 650, y: GROUND_Y - 80, w: 150, h: 20, type: 'platform' });

      // Convergence
      platforms.push({ x: 950, y: GROUND_Y - 150, w: 120, h: 20, type: 'platform' });
      platforms.push({ x: 1150, y: GROUND_Y - 200, w: 100, h: 20, type: 'platform' });
      platforms.push({ x: 1320, y: GROUND_Y - 150, w: 120, h: 20, type: 'platform' });

      // Many enemies
      for (let i = 0; i < 5; i++) {
        enemies.push({ x: 300 + i * 220, y: GROUND_Y - 30, w: 40, h: 30, type: 'hopper', vx: 50, vy: 0, health: 1, dir: i % 2 ? 1 : -1, jumpTimer: 0, animTimer: 0 });
      }
      for (let i = 0; i < 3; i++) {
        enemies.push({ x: 400 + i * 280, y: GROUND_Y - 30, w: 35, h: 35, type: 'walker', vx: 80, health: 1, dir: i % 2 ? 1 : -1, rotateAngle: 0 });
      }
      enemies.push({ x: 500, y: GROUND_Y - 240, w: 45, h: 25, type: 'flyer', vx: 100, vy: 0, health: 1, dir: 1, bobT: 0, flapTimer: 0 });
      enemies.push({ x: 900, y: GROUND_Y - 200, w: 45, h: 25, type: 'flyer', vx: 100, vy: 0, health: 1, dir: -1, bobT: Math.PI, flapTimer: 0 });

      // Coins scattered across paths
      for (let i = 0; i < 5; i++) {
        coins_objs.push({ x: 330 + i * 80, y: GROUND_Y - 380, size: 14, sparkleT: rand(0, Math.PI * 2) });
      }
      for (let i = 0; i < 4; i++) {
        coins_objs.push({ x: 400 + i * 90, y: GROUND_Y - 230, size: 14, sparkleT: rand(0, Math.PI * 2) });
      }

      levelGoal = { x: 1700, y: GROUND_Y - 80, w: 60, h: 80 };
    }
  }

  function reset() {
    gameOver = false;
    levelComplete = false;
    lives = 3;
    score = 0;
    sessionCoins = 0;
    currentLevel = 1;
    loadLevel(currentLevel);
    updateHUD();
    startMusic(currentLevel);
  }

  function nextLevel() {
    levelComplete = false;
    currentLevel++;
    score += 500;
    loadLevel(currentLevel);
    updateHUD();
    startMusic(currentLevel);
  }

  function loseLife() {
    lives--;
    updateHUD();

    if (lives <= 0) {
      gameOver = true;
      coins += sessionCoins;
      localStorage.setItem('rb_moon_coins', coins);
      localStorage.setItem('rb_moon_stats', JSON.stringify(stats));
      stopMusic();
      playSound('hit');
      shakeIntensity = 20;
      createParticle(player.x + player.w / 2, player.y + player.h / 2, '#ff5555', 20);
    } else {
      player.x = 100;
      player.y = GROUND_Y - player.h - 20;
      player.vx = 0;
      player.vy = 0;
      player.invincible = true;
      player.invincibleTimer = 2.0;
      playSound('hit');
      shakeIntensity = 15;
      camera.x = 0;
    }
  }

  function updateHUD() {
    document.getElementById('level').textContent = `Level: ${currentLevel}`;
    document.getElementById('lives').textContent = `Lives: ${lives}`;
    document.getElementById('score').textContent = `Score: ${Math.floor(score)}`;
    document.getElementById('coins').textContent = `Coins: ${coins + sessionCoins}`;
  }

  function drawBackground() {
    // Deep space
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Parallax star layers
    for (const layer of bgLayers) {
      for (const star of layer.elements) {
        const parallaxX = star.x - camera.x * layer.speed;

        if (parallaxX > -50 && parallaxX < canvas.width + 50) {
          star.twinkle += star.twinkleSpeed * 0.05;
          const alpha = 0.3 + Math.sin(star.twinkle) * 0.2;

          ctx.globalAlpha = alpha;
          ctx.fillStyle = layer.color;
          ctx.fillRect(parallaxX, star.y, star.size, star.size);

          // Glow
          if (star.size > 2) {
            ctx.fillStyle = '#7be2ff';
            ctx.fillRect(parallaxX - 0.5, star.y - 0.5, star.size + 1, star.size + 1);
          }
        }
      }
    }
    ctx.globalAlpha = 1;

    // Distant moon surface mountains (parallax)
    ctx.fillStyle = '#0b0f17';
    ctx.strokeStyle = '#1a2530';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-camera.x * 0.2, GROUND_Y - 100);
    for (let x = 0; x <= canvas.width + 200; x += 80) {
      const worldX = x + camera.x * 0.2;
      const y = GROUND_Y - 100 + Math.sin(worldX * 0.008) * 20 + Math.cos(worldX * 0.015) * 15;
      ctx.lineTo(x - camera.x * 0.2, y);
    }
    ctx.lineTo(canvas.width, GROUND_Y);
    ctx.lineTo(0, GROUND_Y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function drawPlayer() {
    const { x, y, w, h } = player;
    const skin = getSkin();

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);

    if (player.invincible) {
      ctx.globalAlpha = 0.5 + Math.sin(time * 20) * 0.5;
    }

    ctx.scale(player.facing, 1);
    ctx.translate(-w / 2, -h / 2);

    // Body with animation offset
    let bodyOffset = 0;
    if (player.animState === 'walk') {
      bodyOffset = Math.sin(player.animFrame * Math.PI) * 2;
    }

    if (skin.body === 'rainbow') {
      const hue = (time * 100) % 360;
      ctx.fillStyle = `hsl(${hue}, 70%, 65%)`;
    } else {
      ctx.fillStyle = skin.body;
    }
    ctx.strokeStyle = skin.shadow;
    ctx.lineWidth = 2;
    roundRect(4, 6 + bodyOffset, w - 8, h - 14, 10, true, true);

    // Feet - animated walk
    let leftFootOffset = 0, rightFootOffset = 0;
    if (player.animState === 'walk') {
      leftFootOffset = Math.sin(player.animFrame * Math.PI * 2) * 3;
      rightFootOffset = Math.sin((player.animFrame + 0.5) * Math.PI * 2) * 3;
    }

    ctx.fillStyle = '#8c97a7';
    roundRect(2 + leftFootOffset, h - 12, w * 0.42, 12, 6, true, false);
    roundRect(w - w * 0.42 - 2 + rightFootOffset, h - 12, w * 0.42, 12, 6, true, false);

    // Ears - animated
    const earW = w * 0.2, earH = h * 0.7;
    let earBounce = 0;
    if (player.animState === 'jump') {
      earBounce = Math.sin(time * 10) * 5;
    } else if (player.animState === 'walk') {
      earBounce = Math.sin(player.animFrame * Math.PI * 2) * 2;
    }

    ctx.fillStyle = skin.body === 'rainbow' ? `hsl(${(time * 100 + 30) % 360}, 70%, 65%)` : skin.body;
    roundRect(w * 0.2, -earH * 0.4 + earBounce, earW, earH, 8, true, true);
    roundRect(w * 0.6, -earH * 0.3 + earBounce * 0.7, earW, earH, 8, true, true);

    // Visor
    ctx.fillStyle = '#0d131a';
    roundRect(w * 0.25, h * 0.35 + bodyOffset, w * 0.5, h * 0.18, 8, true, false);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = skin.accent;
    roundRect(w * 0.3, h * 0.4 + bodyOffset, w * 0.4, h * 0.08, 5, true, false);
    ctx.globalCompositeOperation = 'source-over';

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawPlatform(plat) {
    if (plat.type === 'ground') {
      ctx.fillStyle = '#2a313c';
      ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
      ctx.fillStyle = '#1b1f26';
      ctx.fillRect(plat.x, plat.y + 20, plat.w, plat.h - 20);

      // Surface detail
      ctx.strokeStyle = '#3a4352';
      ctx.lineWidth = 2;
      for (let x = plat.x; x < plat.x + plat.w; x += 40) {
        ctx.strokeRect(x, plat.y + 5, 30, 4);
      }
    } else {
      ctx.fillStyle = '#3a5570';
      ctx.strokeStyle = '#2a4050';
      ctx.lineWidth = 2;
      roundRect(plat.x, plat.y, plat.w, plat.h, 4, true, true);

      // Platform detail
      ctx.strokeStyle = '#4a6580';
      ctx.lineWidth = 1;
      for (let x = 0; x < plat.w - 10; x += 15) {
        ctx.strokeRect(plat.x + x + 5, plat.y + 4, 8, plat.h - 8);
      }
    }
  }

  function drawEnemy(enemy) {
    ctx.save();
    ctx.translate(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2);

    if (enemy.type === 'hopper') {
      // Animated hopper
      enemy.animTimer += 0.1;
      const squish = enemy.vy !== 0 ? (enemy.vy > 0 ? 0.9 : 1.1) : (1 + Math.sin(enemy.animTimer) * 0.05);

      ctx.scale(1, squish);
      ctx.fillStyle = '#c9d0da';
      ctx.strokeStyle = '#8ea0b5';
      ctx.lineWidth = 2;
      roundRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h, 8, true, true);

      // Animated eyes
      const blink = Math.sin(enemy.animTimer * 0.5) > 0.9 ? 2 : 6;
      ctx.fillStyle = '#ff5555';
      ctx.fillRect(-enemy.w * 0.25, -enemy.h * 0.2, 6, blink);
      ctx.fillRect(enemy.w * 0.25 - 6, -enemy.h * 0.2, 6, blink);

      // Antenna
      ctx.strokeStyle = '#8ea0b5';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -enemy.h / 2);
      ctx.lineTo(Math.sin(enemy.animTimer) * 3, -enemy.h / 2 - 10);
      ctx.stroke();
      ctx.fillStyle = '#ff5555';
      ctx.beginPath();
      ctx.arc(Math.sin(enemy.animTimer) * 3, -enemy.h / 2 - 10, 3, 0, Math.PI * 2);
      ctx.fill();

    } else if (enemy.type === 'walker') {
      // Animated rolling walker
      enemy.rotateAngle += 0.15 * enemy.dir;

      ctx.rotate(enemy.rotateAngle);
      ctx.fillStyle = '#a890d0';
      ctx.strokeStyle = '#7860a0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, enemy.w / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Animated spikes
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI * 2 * i) / 6;
        const x = Math.cos(angle) * enemy.w * 0.4;
        const y = Math.sin(angle) * enemy.h * 0.4;
        ctx.fillStyle = '#504070';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x * 1.4, y * 1.4);
        ctx.lineTo(x * 0.9, y * 0.9);
        ctx.closePath();
        ctx.fill();
      }

    } else if (enemy.type === 'flyer') {
      // Animated flyer
      enemy.bobT += 0.08;
      enemy.flapTimer += 0.2;
      const wobble = Math.sin(enemy.bobT) * 3;
      const flapOffset = Math.sin(enemy.flapTimer) * 2;

      ctx.translate(0, wobble);
      ctx.fillStyle = '#7895b8';
      ctx.strokeStyle = '#4a5f7a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, enemy.w / 2, enemy.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Wings
      ctx.fillStyle = 'rgba(120,149,184,0.6)';
      ctx.beginPath();
      ctx.ellipse(-enemy.w * 0.5, flapOffset, enemy.w * 0.3, enemy.h * 0.5, Math.PI / 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(enemy.w * 0.5, flapOffset, enemy.w * 0.3, enemy.h * 0.5, -Math.PI / 4, 0, Math.PI * 2);
      ctx.fill();

      // Animated lights
      const lightPhase = Math.sin(enemy.flapTimer);
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = lightPhase > 0 ? '#ff5555' : '#55ff55';
      ctx.beginPath();
      ctx.arc(-enemy.w * 0.2, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = lightPhase > 0 ? '#55ff55' : '#ff5555';
      ctx.beginPath();
      ctx.arc(enemy.w * 0.2, 0, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    ctx.restore();
  }

  function drawLaser(laser) {
    ctx.save();
    ctx.fillStyle = laser.dir > 0 ? '#ff3333' : '#3333ff';
    ctx.shadowColor = laser.dir > 0 ? '#ff0000' : '#0000ff';
    ctx.shadowBlur = 10;
    roundRect(laser.x - 2, laser.y - 2, laser.w + 4, laser.h + 4, 2, true, false);
    ctx.fillStyle = laser.dir > 0 ? '#ff6666' : '#6666ff';
    roundRect(laser.x, laser.y, laser.w, laser.h, 2, true, false);
    ctx.restore();
  }

  function drawCoin(coin) {
    coin.sparkleT += 0.08;
    ctx.save();
    ctx.translate(coin.x, coin.y);

    const pulse = 1 + Math.sin(coin.sparkleT * 2) * 0.1;
    ctx.scale(pulse, pulse);

    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(0, 0, coin.size * 1.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#FFD700';
    ctx.strokeStyle = '#FFA500';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#FFED4E';
    ctx.beginPath();
    ctx.arc(-coin.size * 0.25, -coin.size * 0.25, coin.size * 0.4, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  function drawLevelGoal(goal) {
    ctx.save();
    ctx.translate(goal.x, goal.y);

    ctx.fillStyle = '#9fb1cc';
    ctx.fillRect(5, 0, 8, goal.h);

    // Animated flag
    const wave = Math.sin(time * 4);
    ctx.fillStyle = '#FFD700';
    ctx.strokeStyle = '#FFA500';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(13, 10);
    ctx.quadraticCurveTo(35 + wave * 5, 15, 50, 20);
    ctx.lineTo(13, 30);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.globalAlpha = 0.3 + Math.sin(time * 3) * 0.2;
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(30, 20, 20, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawParticle(p) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    ctx.globalAlpha = 1;
  }

  function drawAchievementNotifications() {
    for (let i = 0; i < achievementNotifications.length; i++) {
      const notif = achievementNotifications[i];
      const progress = notif.time / notif.duration;
      const y = 120 + i * 80;

      let x;
      if (progress < 0.15) {
        x = canvas.width + (1 - progress / 0.15) * 350;
      } else if (progress > 0.85) {
        x = canvas.width - ((1 - (progress - 0.85) / 0.15) * 350);
      } else {
        x = canvas.width - 340;
      }

      ctx.save();
      ctx.globalAlpha = progress < 0.15 ? progress / 0.15 : (progress > 0.85 ? (1 - (progress - 0.85) / 0.15) : 1);

      const w = 320, h = 70;
      ctx.fillStyle = 'rgba(20, 26, 36, 0.95)';
      roundRect(x, y, w, h, 10, true, false);
      ctx.strokeStyle = 'rgba(123, 226, 255, 0.4)';
      ctx.lineWidth = 2;
      roundRect(x, y, w, h, 10, false, true);

      ctx.font = '32px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(notif.icon, x + 35, y + h / 2);

      ctx.textAlign = 'left';
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 16px system-ui, sans-serif';
      ctx.fillText('Achievement Unlocked!', x + 65, y + 22);
      ctx.fillStyle = '#e6edf3';
      ctx.font = 'bold 14px system-ui, sans-serif';
      ctx.fillText(notif.name, x + 65, y + 40);
      ctx.fillStyle = '#9fb1cc';
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillText(notif.desc, x + 65, y + 56);

      ctx.globalAlpha = 1;
      ctx.restore();
    }
  }

  function drawPauseMenu() {
    if (!paused) return;

    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const cardW = 620, cardH = 480;
    const cx = canvas.width / 2 - cardW / 2, cy = canvas.height / 2 - cardH / 2;
    ctx.fillStyle = 'rgba(16,22,32,0.95)';
    roundRect(cx, cy, cardW, cardH, 14, true, false);
    ctx.strokeStyle = 'rgba(123,226,255,0.3)';
    ctx.lineWidth = 2;
    roundRect(cx, cy, cardW, cardH, 14, false, true);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#e6edf3';
    ctx.font = 'bold 36px system-ui, sans-serif';
    ctx.fillText('PAUSED', canvas.width / 2, cy + 45);

    const tabY = cy + 85;
    const tabW = 150;
    const tabs = [
      { id: 'info', label: 'Info', x: cx + 90 },
      { id: 'shop', label: 'Shop', x: cx + 90 + tabW + 20 }
    ];

    for (const tab of tabs) {
      const isActive = pauseTab === tab.id;
      ctx.fillStyle = isActive ? 'rgba(123,226,255,0.2)' : 'rgba(50,60,80,0.3)';
      roundRect(tab.x, tabY, tabW, 40, 8, true, false);
      if (isActive) {
        ctx.strokeStyle = '#7be2ff';
        ctx.lineWidth = 2;
        roundRect(tab.x, tabY, tabW, 40, 8, false, true);
      }
      ctx.fillStyle = isActive ? '#7be2ff' : '#9fb1cc';
      ctx.font = 'bold 16px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(tab.label, tab.x + tabW / 2, tabY + 26);
    }

    const contentY = cy + 140;

    if (pauseTab === 'info') {
      ctx.font = '16px system-ui, sans-serif';
      ctx.fillStyle = '#9fb1cc';
      ctx.textAlign = 'center';
      ctx.fillText(`Level: ${currentLevel}  ‚Ä¢  Lives: ${lives}  ‚Ä¢  Score: ${Math.floor(score)}  ‚Ä¢  Coins: ${coins + sessionCoins}`, canvas.width / 2, contentY);
      ctx.fillText(`Achievements: ${unlockedAchievements.length}/${achievements.length}  ‚Ä¢  Skins: ${unlockedSkins.length}/${skins.length}`, canvas.width / 2, contentY + 24);

      ctx.font = '15px system-ui, sans-serif';
      ctx.fillStyle = '#7be2ff';
      ctx.textAlign = 'left';
      const controlsX = cx + 40;
      const controlsY = contentY + 60;
      const lineHeight = 24;

      ctx.fillText('Controls:', controlsX, controlsY);
      ctx.fillStyle = '#9fb1cc';
      ctx.fillText('‚Ä¢ ‚Üê ‚Üí          - Move left/right', controlsX, controlsY + lineHeight);
      ctx.fillText('‚Ä¢ Space / ‚Üë    - Jump', controlsX, controlsY + lineHeight * 2);
      ctx.fillText('‚Ä¢ X / Z        - Shoot laser', controlsX, controlsY + lineHeight * 3);
      ctx.fillText('‚Ä¢ ESC / P      - Pause/Resume', controlsX, controlsY + lineHeight * 4);
      ctx.fillText('‚Ä¢ M            - Toggle sound', controlsX, controlsY + lineHeight * 5);

      ctx.fillStyle = '#7be2ff';
      ctx.fillText('Tips:', controlsX, controlsY + lineHeight * 6.5);
      ctx.fillStyle = '#9fb1cc';
      ctx.fillText('‚Ä¢ Jump on enemies to stomp them!', controlsX, controlsY + lineHeight * 7.5);
      ctx.fillText('‚Ä¢ Explore multiple paths for secrets!', controlsX, controlsY + lineHeight * 8.5);
      ctx.fillText('‚Ä¢ Upper paths = more coins & danger!', controlsX, controlsY + lineHeight * 9.5);

    } else if (pauseTab === 'shop') {
      ctx.font = '18px system-ui, sans-serif';
      ctx.fillStyle = '#FFD700';
      ctx.textAlign = 'center';
      ctx.fillText(`üí∞ Your Coins: ${coins}`, canvas.width / 2, contentY);

      const skinsPerRow = 3;
      const skinBoxW = 150;
      const skinBoxH = 80;
      const startX = cx + 60;
      const startY = contentY + 40;

      for (let i = 0; i < skins.length; i++) {
        const skin = skins[i];
        const row = Math.floor(i / skinsPerRow);
        const col = i % skinsPerRow;
        const bx = startX + col * (skinBoxW + 20);
        const by = startY + row * (skinBoxH + 15);

        const isUnlocked = unlockedSkins.includes(skin.id);
        const isActive = currentSkin === skin.id;

        ctx.fillStyle = isActive ? 'rgba(123,226,255,0.3)' : 'rgba(50,60,80,0.3)';
        roundRect(bx, by, skinBoxW, skinBoxH, 8, true, false);

        if (isActive) {
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 3;
          roundRect(bx, by, skinBoxW, skinBoxH, 8, false, true);
        } else if (isUnlocked) {
          ctx.strokeStyle = '#8affc1';
          ctx.lineWidth = 2;
          roundRect(bx, by, skinBoxW, skinBoxH, 8, false, true);
        }

        const previewSize = 28;
        ctx.fillStyle = skin.body === 'rainbow' ? `hsl(${(time * 100) % 360}, 70%, 65%)` : skin.body;
        ctx.beginPath();
        ctx.arc(bx + 25, by + 28, previewSize / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = 'bold 13px system-ui, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#e6edf3';
        ctx.fillText(skin.name, bx + 50, by + 22);

        if (isActive) {
          ctx.fillStyle = '#FFD700';
          ctx.font = '11px system-ui, sans-serif';
          ctx.fillText('‚òÖ EQUIPPED', bx + 50, by + 38);
        } else if (isUnlocked) {
          ctx.fillStyle = '#8affc1';
          ctx.font = '11px system-ui, sans-serif';
          ctx.fillText('‚úì Owned', bx + 50, by + 38);
        } else {
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 12px system-ui, sans-serif';
          ctx.fillText(`${skin.cost} coins`, bx + 50, by + 38);
        }

        if (isUnlocked && !isActive) {
          ctx.fillStyle = '#9fb1cc';
          ctx.font = '10px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(`Press ${i + 1} to equip`, bx + skinBoxW / 2, by + 68);
        } else if (!isUnlocked) {
          ctx.fillStyle = coins >= skin.cost ? '#8affc1' : '#ff5555';
          ctx.font = '10px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(coins >= skin.cost ? `Press ${i + 1} to buy` : 'Not enough coins', bx + skinBoxW / 2, by + 68);
        }
      }
    }

    ctx.textAlign = 'center';
    ctx.font = 'bold 18px system-ui, sans-serif';
    ctx.fillStyle = '#FFD700';
    ctx.fillText('Press ESC or P to Resume', canvas.width / 2, cy + cardH - 30);
  }

  function drawGameOver() {
    if (!gameOver) return;

    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const cardW = 420, cardH = 180;
    const cx = canvas.width / 2 - cardW / 2, cy = canvas.height / 2 - cardH / 2;
    ctx.fillStyle = 'rgba(16,22,32,0.95)';
    roundRect(cx, cy, cardW, cardH, 14, true, false);
    ctx.strokeStyle = 'rgba(123,226,255,0.18)';
    ctx.lineWidth = 2;
    roundRect(cx, cy, cardW, cardH, 14, false, true);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#ff5555';
    ctx.font = 'bold 44px system-ui, sans-serif';
    ctx.fillText('GAME OVER', canvas.width / 2, cy + 60);

    ctx.fillStyle = '#9fb1cc';
    ctx.font = '18px system-ui, sans-serif';
    ctx.fillText(`Final Score: ${Math.floor(score)}  ‚Ä¢  Level: ${currentLevel}`, canvas.width / 2, cy + 95);

    ctx.font = '600 18px system-ui, sans-serif';
    ctx.fillStyle = '#FFD700';
    ctx.fillText('Press Enter to Restart', canvas.width / 2, cy + 130);
  }

  function drawLevelComplete() {
    if (!levelComplete) return;

    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const cardW = 420, cardH = 180;
    const cx = canvas.width / 2 - cardW / 2, cy = canvas.height / 2 - cardH / 2;
    ctx.fillStyle = 'rgba(16,22,32,0.95)';
    roundRect(cx, cy, cardW, cardH, 14, true, false);
    ctx.strokeStyle = 'rgba(255,215,0,0.5)';
    ctx.lineWidth = 2;
    roundRect(cx, cy, cardW, cardH, 14, false, true);

    ctx.textAlign = 'center';
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 44px system-ui, sans-serif';
    ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, cy + 60);

    ctx.fillStyle = '#9fb1cc';
    ctx.font = '18px system-ui, sans-serif';
    ctx.fillText(`Score: ${Math.floor(score)}  ‚Ä¢  +500 Bonus!`, canvas.width / 2, cy + 95);

    ctx.font = '600 18px system-ui, sans-serif';
    ctx.fillStyle = '#8affc1';
    ctx.fillText('Press Enter for Next Level', canvas.width / 2, cy + 130);
  }

  function update(dt) {
    if (gameOver || levelComplete || paused) return;

    time += dt;

    // Player animation
    if (player.onGround) {
      if (Math.abs(player.vx) > 50) {
        player.animState = 'walk';
        player.animTimer += dt * Math.abs(player.vx) / 100;
        player.animFrame = player.animTimer % 1;
      } else {
        player.animState = 'idle';
        player.animFrame = 0;
      }
    } else {
      player.animState = 'jump';
    }

    if (player.invincibleTimer > 0) {
      player.invincibleTimer -= dt;
      player.invincible = player.invincibleTimer > 0;
    }

    if (player.shootCooldown > 0) player.shootCooldown -= dt;

    // Movement
    if (keys.ArrowLeft) {
      player.vx -= moveSpeed * dt * 8;
      player.facing = -1;
    }
    if (keys.ArrowRight) {
      player.vx += moveSpeed * dt * 8;
      player.facing = 1;
    }

    if (!keys.ArrowLeft && !keys.ArrowRight) {
      player.vx *= 0.85;
    }

    player.vx = clamp(player.vx, -maxVelX, maxVelX);

    if ((keys.Space || keys.ArrowUp) && player.onGround) {
      player.vy = jumpVel;
      player.onGround = false;
      playSound('jump');
      createParticle(player.x + player.w / 2, player.y + player.h, '#7be2ff', 6);
    }

    if (wantShoot && player.shootCooldown <= 0) {
      lasers.push({
        x: player.x + (player.facing > 0 ? player.w : 0),
        y: player.y + player.h / 2 - 2,
        w: 20, h: 4,
        vx: player.facing * 500,
        dir: player.facing
      });
      player.shootCooldown = 0.3;
      playSound('shoot');
      createParticle(player.x + player.w / 2, player.y + player.h / 2, player.facing > 0 ? '#ff3333' : '#3333ff', 4);
    }
    wantShoot = false;

    player.vy += gravity * dt;
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    player.onGround = false;
    for (const plat of platforms) {
      if (rectsOverlap(player.x, player.y, player.w, player.h, plat.x, plat.y, plat.w, plat.h)) {
        if (player.vy > 0 && player.y + player.h - player.vy * dt < plat.y + 10) {
          player.y = plat.y - player.h;
          player.vy = 0;
          player.onGround = true;
        } else if (player.vy < 0 && player.y - player.vy * dt > plat.y + plat.h - 10) {
          player.y = plat.y + plat.h;
          player.vy = 0;
        } else if (player.vx > 0) {
          player.x = plat.x - player.w;
          player.vx = 0;
        } else if (player.vx < 0) {
          player.x = plat.x + plat.w;
          player.vx = 0;
        }
      }
    }

    if (player.x < 0) player.x = 0;
    if (player.y > canvas.height + 100) loseLife();

    camera.x = player.x - canvas.width / 3;
    camera.x = Math.max(0, camera.x);

    // Update lasers
    for (let i = lasers.length - 1; i >= 0; i--) {
      const laser = lasers[i];
      laser.x += laser.vx * dt;

      if (laser.x < camera.x - 100 || laser.x > camera.x + canvas.width + 100) {
        lasers.splice(i, 1);
        continue;
      }

      for (let j = enemies.length - 1; j >= 0; j--) {
        const enemy = enemies[j];
        if (rectsOverlap(laser.x, laser.y, laser.w, laser.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
          enemy.health--;
          lasers.splice(i, 1);
          createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#ff5555', 10);
          playSound('stomp');
          score += 10;
          stats.laserHits = (stats.laserHits || 0) + 1;
          if (enemy.health <= 0) {
            enemies.splice(j, 1);
            stats.enemiesDefeated = (stats.enemiesDefeated || 0) + 1;
            score += 50;
          }
          break;
        }
      }
    }

    // Update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];

      if (enemy.type === 'hopper') {
        enemy.jumpTimer -= dt;
        if (enemy.jumpTimer <= 0 && enemy.vy === 0) {
          enemy.vy = -600;
          enemy.jumpTimer = rand(1.5, 3.0);
        }
        enemy.vy += gravity * dt;
        enemy.y += enemy.vy * dt;
        enemy.x += enemy.dir * enemy.vx * dt;

        for (const plat of platforms) {
          if (rectsOverlap(enemy.x, enemy.y, enemy.w, enemy.h, plat.x, plat.y, plat.w, plat.h)) {
            if (enemy.vy > 0) {
              enemy.y = plat.y - enemy.h;
              enemy.vy = 0;
            }
          }
        }

      } else if (enemy.type === 'walker') {
        enemy.x += enemy.dir * enemy.vx * dt;

        let foundGround = false;
        for (const plat of platforms) {
          if (rectsOverlap(enemy.x + enemy.dir * 10, enemy.y + enemy.h, 10, 10, plat.x, plat.y, plat.w, plat.h)) {
            foundGround = true;
          }
          if (rectsOverlap(enemy.x, enemy.y, enemy.w, enemy.h, plat.x, plat.y, plat.w, plat.h)) {
            enemy.dir *= -1;
          }
        }
        if (!foundGround) enemy.dir *= -1;

      } else if (enemy.type === 'flyer') {
        enemy.x += enemy.dir * enemy.vx * dt;

        if (enemy.x < camera.x - 50 || enemy.x > camera.x + canvas.width + 50) {
          enemy.dir *= -1;
        }
      }

      if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
        if (player.vy > 0 && player.y + player.h * 0.6 < enemy.y + enemy.h / 2) {
          enemy.health--;
          player.vy = jumpVel * 0.6;
          createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#FFD700', 12);
          playSound('stomp');
          score += 100;
          stats.stomps = (stats.stomps || 0) + 1;
          if (enemy.health <= 0) {
            enemies.splice(i, 1);
            stats.enemiesDefeated = (stats.enemiesDefeated || 0) + 1;
            score += 50;
          }
        } else {
          loseLife();
        }
      }
    }

    // Update coins
    for (let i = coins_objs.length - 1; i >= 0; i--) {
      const coin = coins_objs[i];
      if (rectsOverlap(player.x, player.y, player.w, player.h, coin.x - coin.size, coin.y - coin.size, coin.size * 2, coin.size * 2)) {
        coins_objs.splice(i, 1);
        sessionCoins++;
        score += 10;
        createParticle(coin.x, coin.y, '#FFD700', 8);
        playSound('coin');
        updateHUD();
      }
    }

    if (levelGoal && rectsOverlap(player.x, player.y, player.w, player.h, levelGoal.x, levelGoal.y, levelGoal.w, levelGoal.h)) {
      levelComplete = true;
      coins += sessionCoins;
      sessionCoins = 0;
      localStorage.setItem('rb_moon_coins', coins);
      localStorage.setItem('rb_moon_stats', JSON.stringify(stats));
      playSound('levelComplete');
      stopMusic();
      createParticle(levelGoal.x + levelGoal.w / 2, levelGoal.y + levelGoal.h / 2, '#FFD700', 30);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += gravity * 0.5 * dt;
      p.life -= p.decay * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }

    for (let i = achievementNotifications.length - 1; i >= 0; i--) {
      achievementNotifications[i].time += dt;
      if (achievementNotifications[i].time >= achievementNotifications[i].duration) {
        achievementNotifications.splice(i, 1);
      }
    }

    shakeIntensity = Math.max(0, shakeIntensity - dt * 10);
    shakeX = (Math.random() - 0.5) * shakeIntensity;
    shakeY = (Math.random() - 0.5) * shakeIntensity;

    checkAchievements();
    updateHUD();
  }

  function draw() {
    ctx.save();
    ctx.translate(shakeX, shakeY);

    drawBackground();

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    for (const plat of platforms) drawPlatform(plat);
    for (const coin of coins_objs) drawCoin(coin);
    if (levelGoal) drawLevelGoal(levelGoal);
    for (const enemy of enemies) drawEnemy(enemy);
    for (const laser of lasers) drawLaser(laser);
    drawPlayer();
    for (const p of particles) drawParticle(p);

    ctx.restore();
    ctx.restore();

    drawAchievementNotifications();
    drawPauseMenu();
    drawGameOver();
    drawLevelComplete();
  }

  let last = performance.now();
  function loop(now) {
    const rawDt = (now - last) / 1000;
    last = now;
    const dt = Math.min(1 / 30, rawDt);

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  initBackground();
  loadLevel(currentLevel);
  updateHUD();
  startMusic(currentLevel);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
