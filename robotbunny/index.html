<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Robot Bunny Platformer ‚Äî Endless Moon Edition</title>
<style>
  :root {
    --bg-deep: #000000;
    --bg-halo: #0a0f18;
  }
  html, body { height: 100%; margin: 0; background: var(--bg-deep); color: #e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
  #wrap { display: grid; place-items: center; height: 100%; }
  canvas {
    background: radial-gradient(1000px 600px at 50% -200px, var(--bg-halo), var(--bg-deep) 55%);
    width: min(100vw, 960px);
    height: min(62vh, 560px);
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0,0,0,.45), inset 0 0 80px rgba(123,226,255,0.03);
  }
  @media (max-width: 768px), (pointer: coarse) {
    canvas {
      width: 100vw;
      height: calc(100vh - 200px);
      border-radius: 0;
      max-height: 600px;
    }
  }
  .hud {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
    font-weight: 650; letter-spacing: .2px; text-shadow: 0 0 8px rgba(123,226,255,.15);
    font-size: 13px; max-width: 90vw;
  }
  .hud-item { display: flex; align-items: center; gap: 5px; padding: 3px 8px; background: rgba(16,22,32,0.85); border-radius: 5px; border: 1px solid rgba(123,226,255,0.25); }
  .combo-display {
    position: fixed; top: 100px; right: 20px;
    font-size: 32px; font-weight: 900; color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.4);
    animation: pulse 0.5s ease-in-out infinite alternate;
    display: none;
  }
  .combo-display.active { display: block; }
  @media (max-width: 768px), (pointer: coarse) {
    .combo-display {
      top: 60px;
      right: 10px;
      font-size: 24px;
    }
  }
  @keyframes pulse {
    from { transform: scale(1); }
    to { transform: scale(1.1); }
  }
  .hint { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); opacity: .8; font-size: 12px; color: #9fb1cc; text-align: center; max-width: 90vw; }
  .badge { position: fixed; top: 10px; right: 14px; font-size: 11px; color: #9fb1cc; opacity: .8; }
  @media (max-width: 768px), (pointer: coarse) {
    .hint { bottom: 200px; font-size: 11px; }
    .badge { display: none; }
  }
  .start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center;
    flex-direction: column; gap: 20px;
    z-index: 1000; cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  .start-screen.hidden { display: none; }
  .start-title {
    font-size: 32px; font-weight: bold; color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.5);
    text-align: center; padding: 0 20px;
  }
  .start-button {
    padding: 20px 60px; font-size: 28px; font-weight: bold; color: #7be2ff;
    background: rgba(123,226,255,0.1); border: 3px solid #7be2ff; border-radius: 15px;
    cursor: pointer; transition: all 0.3s;
    user-select: none; -webkit-user-select: none;
    touch-action: manipulation;
    min-width: 250px; text-align: center;
  }
  .start-button:hover, .start-button:active {
    background: rgba(123,226,255,0.2); box-shadow: 0 0 20px rgba(123,226,255,0.5);
    transform: scale(1.05);
  }
  @media (max-width: 768px) {
    .start-title { font-size: 24px; }
    .start-button {
      padding: 25px 50px;
      font-size: 24px;
      min-width: 200px;
    }
  }

  /* Mobile Controls */
  .mobile-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 180px;
    display: none;
    pointer-events: none;
    z-index: 100;
  }
  @media (max-width: 768px), (pointer: coarse) {
    .mobile-controls { display: block; }
    .hud { top: 5px; font-size: 11px; gap: 5px; }
    .hud-item { padding: 2px 6px; }
  }
  .mobile-btn {
    position: absolute;
    background: rgba(123, 226, 255, 0.2);
    border: 3px solid rgba(123, 226, 255, 0.5);
    border-radius: 50%;
    color: #7be2ff;
    font-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
    pointer-events: auto;
    -webkit-tap-highlight-color: transparent;
    box-shadow: 0 0 15px rgba(123, 226, 255, 0.3);
  }
  .mobile-btn:active {
    background: rgba(123, 226, 255, 0.3);
    border-color: rgba(123, 226, 255, 0.6);
    transform: scale(0.95);
  }
  .mobile-btn.pressed {
    background: rgba(123, 226, 255, 0.4);
    border-color: rgba(123, 226, 255, 0.8);
  }
  #mobile-left {
    left: 15px;
    bottom: 15px;
    width: 80px;
    height: 80px;
  }
  #mobile-right {
    left: 110px;
    bottom: 15px;
    width: 80px;
    height: 80px;
  }
  #mobile-jump {
    right: 110px;
    bottom: 15px;
    width: 90px;
    height: 90px;
    font-size: 16px;
  }
  #mobile-shoot {
    right: 15px;
    bottom: 15px;
    width: 80px;
    height: 80px;
    font-size: 28px;
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="560" aria-label="Robot Bunny Platformer"></canvas>
</div>
<div class="hud">
  <div class="hud-item"><span>üåô</span><span id="level">Level 1</span></div>
  <div class="hud-item"><span>‚ù§Ô∏è</span><span id="lives">√ó3</span></div>
  <div class="hud-item"><span>üéØ</span><span id="score">0</span></div>
  <div class="hud-item"><span>ü™ô</span><span id="coins">0</span></div>
  <div class="hud-item"><span>‚≠ê</span><span id="upgrades">Upgrades: 0</span></div>
</div>
<div class="combo-display" id="combo-display">COMBO x0</div>
<div class="hint" id="hint-text">Move: ‚Üê‚Üí ‚Ä¢ Jump: Space ‚Ä¢ Shoot: X ‚Ä¢ Pause: ESC</div>
<div class="badge">Endless Edition</div>
<div class="start-screen" id="start-screen">
  <div class="start-title">üê∞ ROBOT BUNNY üåô</div>
  <div class="start-button">TAP TO START</div>
</div>

<div class="mobile-controls">
  <div class="mobile-btn" id="mobile-left">‚Üê</div>
  <div class="mobile-btn" id="mobile-right">‚Üí</div>
  <div class="mobile-btn" id="mobile-jump">JUMP</div>
  <div class="mobile-btn" id="mobile-shoot">‚ú¶</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function fit() {
    const maxW = Math.min(window.innerWidth, 960);
    const maxH = Math.min(window.innerHeight * 0.62, 560);
    const ar = canvas.width / canvas.height;
    let w = maxW, h = w / ar;
    if (h > maxH) { h = maxH; w = h * ar; }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', fit); fit();

  // ============ UTILITY FUNCTIONS ============
  function rand(a, b) { return a + Math.random() * (b - a); }
  function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
  }
  function roundRect(x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ============ CONSTANTS ============
  const GROUND_Y = canvas.height - 80;
  const gravity = 2200;
  const jumpVel = -950;
  const moveSpeed = 250;
  const maxVelX = 350;

  // ============ GAME STATE ============
  let gameState = 'playing'; // playing, levelComplete, shop, gameOver, bossIntro
  let gameStarted = false;
  let time = 0;
  let score = 0;
  let currentLevel = 1;
  let segmentsInLevel = 0;
  const segmentsPerLevel = 4; // 4 segments + boss
  let paused = false;
  let camera = { x: 0, y: 0 };
  let shake = { x: 0, y: 0, intensity: 0 };
  let bossIntroTimer = 0;

  // ============ PERSISTENT DATA ============
  let totalCoins = parseInt(localStorage.getItem('rb_endless_coins') || '0');
  let highestLevel = parseInt(localStorage.getItem('rb_endless_highest') || '1');

  // Permanent upgrades (persist across runs)
  const permanentUpgrades = {
    maxHealth: parseInt(localStorage.getItem('rb_upg_health') || '3'),
    moveSpeed: parseInt(localStorage.getItem('rb_upg_speed') || '0'),
    jumpPower: parseInt(localStorage.getItem('rb_upg_jump') || '0'),
    damage: parseInt(localStorage.getItem('rb_upg_damage') || '0'),
    coinMultiplier: parseInt(localStorage.getItem('rb_upg_coins') || '0')
  };

  function saveProgress() {
    localStorage.setItem('rb_endless_coins', totalCoins);
    localStorage.setItem('rb_endless_highest', highestLevel);
    localStorage.setItem('rb_upg_health', permanentUpgrades.maxHealth);
    localStorage.setItem('rb_upg_speed', permanentUpgrades.moveSpeed);
    localStorage.setItem('rb_upg_jump', permanentUpgrades.jumpPower);
    localStorage.setItem('rb_upg_damage', permanentUpgrades.damage);
    localStorage.setItem('rb_upg_coins', permanentUpgrades.coinMultiplier);
  }

  // ============ PLAYER ============
  const player = {
    x: 100, y: GROUND_Y - 72, w: 48, h: 64,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    shootCooldown: 0,
    invincible: false,
    invincibleTimer: 0,
    lives: permanentUpgrades.maxHealth,
    maxLives: permanentUpgrades.maxHealth,
    animState: 'idle',
    animFrame: 0,
    animTimer: 0,
    combo: 0,
    comboTimer: 0,
    sessionCoins: 0
  };

  // ============ INPUT ============
  const keys = {};
  let wantShoot = false;

  // ============ ENTITIES ============
  const lasers = [];
  const particles = [];
  const damageNumbers = [];
  const segments = [];
  let currentSegmentIndex = 0;
  let nextSegmentX = 0;
  let boss = null;
  let levelGoal = null;

  // ============ BACKGROUND ============
  const bgLayers = [
    { elements: [], speed: 0.1, color: '#0a0f18' },
    { elements: [], speed: 0.3, color: '#1a2530' },
    { elements: [], speed: 0.5, color: '#2a3540' }
  ];

  // ============ AUDIO SYSTEM ============
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();
  let soundEnabled = true;
  let currentMusic = null;
  let currentMusicTrack = null; // Track which music should be playing
  let musicGain = null;
  let musicReady = false; // Track if user has interacted

  // Music tracks - loaded from 'sounds' folder
  const musicTracks = {
    level: new Audio('sounds/level.mp3'),
    boss: new Audio('sounds/boss.mp3'),
    shop: new Audio('sounds/shop.mp3'),
    victory: new Audio('sounds/victory.mp3')
  };

  // Set all tracks to loop and preload
  for (const track in musicTracks) {
    musicTracks[track].loop = true;
    musicTracks[track].volume = 0.4; // Adjust volume (0.0 to 1.0)
    musicTracks[track].preload = 'auto';
  }

  function playMusic(trackName) {
    currentMusicTrack = trackName; // Remember what should be playing

    if (!soundEnabled) return;

    stopMusic();

    currentMusic = musicTracks[trackName];
    if (currentMusic) {
      currentMusic.currentTime = 0; // Start from beginning
      const playPromise = currentMusic.play();

      if (playPromise !== undefined) {
        playPromise.then(() => {
          musicReady = true;
          console.log(`Music playing: ${trackName}`);
        }).catch(err => {
          console.log(`Music play failed for ${trackName}:`, err.message);
          // Retry on next user interaction
          document.addEventListener('click', () => resumeMusic(), { once: true });
          document.addEventListener('keydown', () => resumeMusic(), { once: true });
        });
      }
    }
  }

  function stopMusic() {
    if (currentMusic) {
      currentMusic.pause();
      currentMusic.currentTime = 0;
    }
    currentMusic = null;
    currentMusicTrack = null; // Clear the track so health check doesn't restart it
  }

  function pauseMusic() {
    if (currentMusic && !currentMusic.paused) {
      currentMusic.pause();
    }
  }

  function resumeMusic() {
    if (!soundEnabled) return;

    // If we have a track that should be playing but isn't, restart it
    if (currentMusicTrack && (!currentMusic || currentMusic.paused)) {
      currentMusic = musicTracks[currentMusicTrack];
      if (currentMusic) {
        const playPromise = currentMusic.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            musicReady = true;
            console.log(`Music resumed: ${currentMusicTrack}`);
          }).catch(err => {
            console.log(`Music resume failed:`, err.message);
          });
        }
      }
    }
  }

  // Haptic feedback for mobile
  function vibrate(pattern) {
    if ('vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }

  function playSound(type, volume = 0.15) {
    if (!soundEnabled) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    switch(type) {
      case 'jump':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
      case 'shoot':
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now); osc.stop(now + 0.08);
        break;
      case 'coin':
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
        break;
      case 'hit':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(volume * 1.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
        break;
      case 'stomp':
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
      case 'levelup':
        osc.frequency.setValueAtTime(523, now);
        osc.frequency.setValueAtTime(659, now + 0.1);
        osc.frequency.setValueAtTime(784, now + 0.2);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now); osc.stop(now + 0.4);
        break;
      case 'combo':
        osc.frequency.setValueAtTime(1000 + player.combo * 50, now);
        gain.gain.setValueAtTime(volume * 0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
        break;
    }
  }

  // ============ PARTICLES & EFFECTS ============
  function createParticle(x, y, color, count = 8, size = 5) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + rand(-0.3, 0.3);
      const speed = rand(100, 250);
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - rand(50, 150),
        life: 1.0,
        decay: rand(1.5, 2.5),
        size: rand(3, size),
        color
      });
    }
  }

  function createDamageNumber(x, y, value, color = '#FFD700') {
    damageNumbers.push({
      x, y: y - 10,
      value: value,
      life: 1.0,
      color: color,
      vy: -100
    });
  }

  function addCombo() {
    player.combo++;
    player.comboTimer = 2.0;

    if (player.combo % 5 === 0) {
      playSound('combo');
    }

    updateComboDisplay();
  }

  function resetCombo() {
    player.combo = 0;
    updateComboDisplay();
  }

  function updateComboDisplay() {
    const display = document.getElementById('combo-display');
    if (player.combo >= 3) {
      display.textContent = `COMBO √ó${player.combo}`;
      display.classList.add('active');
    } else {
      display.classList.remove('active');
    }
  }

  // ============ LEVEL GENERATION ============
  function initBackground() {
    for (const layer of bgLayers) {
      layer.elements = [];
      const count = layer.speed < 0.3 ? 80 : (layer.speed < 0.5 ? 50 : 30);
      for (let i = 0; i < count; i++) {
        layer.elements.push({
          x: rand(0, 4000),
          y: rand(0, GROUND_Y - 50),
          size: layer.speed < 0.3 ? rand(1, 2) : (layer.speed < 0.5 ? rand(2, 3) : rand(3, 4)),
          twinkle: rand(0, Math.PI * 2),
          twinkleSpeed: rand(1, 3)
        });
      }
    }
  }

  function generateSegment(isLast = false) {
    const difficulty = currentLevel;
    const width = randInt(1400, 1800);
    const segment = {
      id: currentSegmentIndex,
      startX: nextSegmentX,
      width: width,
      platforms: [],
      enemies: [],
      coins: []
    };

    // Ground platform
    segment.platforms.push({
      x: segment.startX,
      y: GROUND_Y + 40,
      w: width,
      h: 200,
      type: 'ground'
    });

    const gapMax = 180 + difficulty * 8;
    const platformCount = Math.floor(width / 200);

    let currentX = segment.startX + 150;
    let currentY = GROUND_Y - 100;

    // Create branching paths
    const pathHeight = [GROUND_Y - 100, GROUND_Y - 220, GROUND_Y - 340];
    let currentPath = 0;

    for (let i = 0; i < platformCount; i++) {
      const gap = rand(100, gapMax);
      const platformW = randInt(80, 140);

      // Occasionally switch paths
      if (Math.random() < 0.3 && i > 1) {
        const newPath = randInt(0, 2);
        currentPath = newPath;
      }

      currentX += gap;
      currentY = pathHeight[currentPath] + rand(-30, 30);
      currentY = clamp(currentY, GROUND_Y - 380, GROUND_Y - 60);

      segment.platforms.push({
        x: currentX,
        y: currentY,
        w: platformW,
        h: 20,
        type: 'platform',
        path: currentPath // 0=low, 1=mid, 2=high
      });

      // More rewards on high path
      const coinMultiplier = currentPath === 2 ? 2 : (currentPath === 1 ? 1.5 : 1);

      // Spawn enemies (more on low path)
      if (Math.random() < 0.35 + (2 - currentPath) * 0.1) {
        const enemyTypes = ['hopper', 'walker'];
        if (difficulty >= 3) enemyTypes.push('flyer');
        const type = enemyTypes[randInt(0, enemyTypes.length - 1)];

        const enemy = {
          type: type,
          x: currentX + rand(10, platformW - 50),
          y: currentY - (type === 'flyer' ? 80 : 30),
          w: type === 'flyer' ? 45 : (type === 'walker' ? 35 : 40),
          h: type === 'flyer' ? 25 : 30,
          vx: (type === 'walker' ? 80 : (type === 'flyer' ? 100 : 50)) * (1 + difficulty * 0.04),
          vy: 0,
          health: 1 + Math.floor(difficulty / 4),
          maxHealth: 1 + Math.floor(difficulty / 4),
          dir: Math.random() > 0.5 ? 1 : -1,
          animTimer: 0,
          rotateAngle: 0,
          bobT: rand(0, Math.PI * 2),
          flapTimer: 0,
          jumpTimer: type === 'hopper' ? rand(1, 3) : 0
        };
        segment.enemies.push(enemy);
      }

      // Add coins
      if (Math.random() < 0.6 * coinMultiplier) {
        const coinCount = randInt(1, Math.floor(2 * coinMultiplier));
        for (let c = 0; c < coinCount; c++) {
          segment.coins.push({
            x: currentX + rand(20, platformW - 40) + c * 25,
            y: currentY - rand(40, 90),
            size: 14,
            sparkleT: rand(0, Math.PI * 2),
            value: currentPath === 2 ? 2 : 1 // High path = 2x coins
          });
        }
      }

      currentX += platformW;
    }

    // Level goal at end of last segment (before boss)
    if (isLast) {
      levelGoal = {
        x: currentX + 100,
        y: GROUND_Y - 120,
        w: 60,
        h: 100
      };
    }

    return segment;
  }

  function loadNextSegment() {
    segmentsInLevel++;
    const isLastBeforeBoss = segmentsInLevel >= segmentsPerLevel;
    const segment = generateSegment(isLastBeforeBoss);
    segments.push(segment);
    nextSegmentX += segment.width;
    currentSegmentIndex++;
  }

  function spawnBoss() {
    const bossX = nextSegmentX + 200;
    const difficulty = currentLevel;

    boss = {
      x: bossX,
      y: GROUND_Y - 120,
      w: 100 + difficulty * 5,
      h: 90 + difficulty * 5,
      vx: 0,
      vy: 0,
      health: 10 + difficulty * 5,
      maxHealth: 10 + difficulty * 5,
      state: 'idle', // idle, charging, attacking
      stateTimer: 0,
      attackCooldown: 0,
      phase: 0,
      dir: -1,
      animTimer: 0,
      hitFlash: 0,
      attacks: ['charge', 'jump'],
      currentAttack: null
    };

    if (difficulty >= 3) boss.attacks.push('projectiles');

    gameState = 'bossIntro';
    bossIntroTimer = 0; // Reset intro timer
    playMusic('boss');
  }

  function unloadOldSegments() {
    while (segments.length > 0 && segments[0].startX + segments[0].width < camera.x - 500) {
      segments.shift();
    }
  }

  // ============ BOSS AI ============
  function updateBoss(dt) {
    if (!boss || boss.health <= 0) return;

    boss.animTimer += dt;
    boss.stateTimer += dt;
    boss.attackCooldown -= dt;

    if (boss.hitFlash > 0) boss.hitFlash -= dt * 5;

    // Update phase based on health
    const healthPercent = boss.health / boss.maxHealth;
    if (healthPercent < 0.33) boss.phase = 2;
    else if (healthPercent < 0.66) boss.phase = 1;

    switch (boss.state) {
      case 'idle':
        // Move towards player
        if (boss.x > player.x + 200) {
          boss.x -= 60 * dt;
          boss.dir = -1;
        } else if (boss.x < player.x - 200) {
          boss.x += 60 * dt;
          boss.dir = 1;
        }

        // Pick attack
        if (boss.attackCooldown <= 0 && boss.stateTimer > 1.0) {
          boss.currentAttack = boss.attacks[randInt(0, boss.attacks.length - 1)];
          boss.state = 'charging';
          boss.stateTimer = 0;
        }
        break;

      case 'charging':
        if (boss.stateTimer > 0.8) {
          boss.state = 'attacking';
          boss.stateTimer = 0;
        }
        break;

      case 'attacking':
        if (boss.currentAttack === 'charge') {
          boss.x += boss.dir * 300 * dt;

          if (boss.stateTimer > 1.5) {
            boss.state = 'idle';
            boss.attackCooldown = 3.0;
            boss.stateTimer = 0;
          }
        } else if (boss.currentAttack === 'jump') {
          if (boss.stateTimer < 0.4) {
            boss.vy = -800;
          } else if (boss.stateTimer < 1.2) {
            boss.vy += gravity * dt;
            boss.y += boss.vy * dt;

            if (boss.y >= GROUND_Y - boss.h) {
              boss.y = GROUND_Y - boss.h;
              shake.intensity = 20;
              createParticle(boss.x + boss.w / 2, boss.y + boss.h, '#ff5555', 30, 10);
            }
          } else {
            boss.vy = 0;
            boss.state = 'idle';
            boss.attackCooldown = 2.5;
            boss.stateTimer = 0;
          }
        } else if (boss.currentAttack === 'projectiles') {
          if (boss.stateTimer === 0 || (Math.floor(boss.stateTimer * 5) > Math.floor((boss.stateTimer - dt) * 5) && boss.stateTimer < 1.0)) {
            const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
            lasers.push({
              x: boss.x + boss.w / 2,
              y: boss.y + boss.h / 2,
              w: 16, h: 16,
              vx: Math.cos(angle) * 300,
              vy: Math.sin(angle) * 300,
              dir: 0,
              isBossProjectile: true
            });
          }

          if (boss.stateTimer > 1.5) {
            boss.state = 'idle';
            boss.attackCooldown = 4.0;
            boss.stateTimer = 0;
          }
        }
        break;
    }

    // Check collision with player (full hitbox including tentacles)
    const bossHitboxHeight = boss.h + 75; // Include tentacles
    if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, boss.x, boss.y, boss.w, bossHitboxHeight)) {
      loseLife();
    }
  }

  // ============ GAME LOOP ============
  function loseLife() {
    player.lives--;
    resetCombo();

    if (player.lives <= 0) {
      gameState = 'gameOver';
      stopMusic();
      playSound('hit');
      vibrate([100, 50, 100]); // Haptic feedback for game over
      shake.intensity = 25;
      createParticle(player.x + player.w / 2, player.y + player.h / 2, '#ff5555', 30);
    } else {
      player.x = camera.x + 100;
      player.y = GROUND_Y - player.h - 20;
      player.vx = 0;
      player.vy = 0;
      player.invincible = true;
      player.invincibleTimer = 2.5;
      playSound('hit');
      vibrate(50); // Haptic feedback for losing life
      shake.intensity = 18;
    }
  }

  function completeLevel() {
    gameState = 'levelComplete';
    stopMusic();
    playMusic('victory'); // Play victory music
    playSound('levelup');

    // Award coins
    totalCoins += player.sessionCoins;
    if (currentLevel > highestLevel) {
      highestLevel = currentLevel;
    }
    saveProgress();
  }

  function startNextLevel() {
    currentLevel++;
    segmentsInLevel = 0;
    boss = null;
    levelGoal = null;
    segments.length = 0;
    lasers.length = 0;
    particles.length = 0;
    damageNumbers.length = 0;
    currentSegmentIndex = 0;
    nextSegmentX = 0;

    player.x = 100;
    player.y = GROUND_Y - player.h - 20;
    player.vx = 0;
    player.vy = 0;
    player.sessionCoins = 0;
    camera.x = 0;

    resetCombo();

    // Load initial segments
    for (let i = 0; i < 3; i++) {
      loadNextSegment();
    }

    gameState = 'playing';
    playMusic('level');
  }

  function updateHUD() {
    document.getElementById('level').textContent = `Level ${currentLevel}`;
    document.getElementById('lives').textContent = `√ó${player.lives}`;
    document.getElementById('score').textContent = Math.floor(score);
    document.getElementById('coins').textContent = player.sessionCoins + totalCoins;

    const upgradeCount = permanentUpgrades.maxHealth - 3 +
                        permanentUpgrades.moveSpeed +
                        permanentUpgrades.jumpPower +
                        permanentUpgrades.damage +
                        permanentUpgrades.coinMultiplier;
    document.getElementById('upgrades').textContent = `Upgrades: ${upgradeCount}`;
  }

  function update(dt) {
    if (paused || !gameStarted) return;

    time += dt;

    // Music health check - ensure music is playing when it should be
    if (soundEnabled && currentMusicTrack && gameState !== 'gameOver') {
      if (!currentMusic || currentMusic.paused || currentMusic.ended) {
        resumeMusic();
      }
    }

    // Update combo timer
    if (player.comboTimer > 0) {
      player.comboTimer -= dt;
      if (player.comboTimer <= 0) {
        resetCombo();
      }
    }

    if (gameState === 'playing') {
      updatePlaying(dt);
    } else if (gameState === 'bossIntro') {
      bossIntroTimer += dt;

      // Pan camera to boss over 1.5 seconds
      const targetCameraX = boss.x - 300;
      const distance = targetCameraX - camera.x;
      camera.x += distance * (dt / (1.5 - bossIntroTimer + 0.01));

      // Transition to playing after 1.5 seconds
      if (bossIntroTimer >= 1.5) {
        gameState = 'playing';
        camera.x = targetCameraX; // Snap to final position
        // Ensure boss music is still playing
        if (!currentMusic || currentMusic.paused) {
          resumeMusic();
        }
      }
    } else if (gameState === 'levelComplete') {
      // Wait for input
    } else if (gameState === 'shop') {
      // Shop UI
    } else if (gameState === 'gameOver') {
      // Wait for restart
    }

    // Update particles always
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += gravity * 0.5 * dt;
      p.life -= p.decay * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Update damage numbers
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
      const dn = damageNumbers[i];
      dn.y += dn.vy * dt;
      dn.life -= dt * 1.2;
      if (dn.life <= 0) damageNumbers.splice(i, 1);
    }

    shake.intensity = Math.max(0, shake.intensity - dt * 15);
    shake.x = (Math.random() - 0.5) * shake.intensity;
    shake.y = (Math.random() - 0.5) * shake.intensity;

    updateHUD();
  }

  function updatePlaying(dt) {
    // Update player
    if (player.invincibleTimer > 0) {
      player.invincibleTimer -= dt;
      player.invincible = player.invincibleTimer > 0;
    }

    if (player.shootCooldown > 0) player.shootCooldown -= dt;

    // Player animation
    if (player.onGround) {
      if (Math.abs(player.vx) > 50) {
        player.animState = 'walk';
        player.animTimer += dt * Math.abs(player.vx) / 100;
        player.animFrame = player.animTimer % 1;
      } else {
        player.animState = 'idle';
        player.animFrame = 0;
      }
    } else {
      player.animState = 'jump';
    }

    // Movement with upgrades
    const speedBonus = 1 + permanentUpgrades.moveSpeed * 0.15;
    const jumpBonus = 1 + permanentUpgrades.jumpPower * 0.12;

    const moveLeft = keys.ArrowLeft;
    const moveRight = keys.ArrowRight;
    const wantJump = keys.Space || keys.ArrowUp;

    if (moveLeft) {
      player.vx -= moveSpeed * speedBonus * dt * 8;
      player.facing = -1;
    }
    if (moveRight) {
      player.vx += moveSpeed * speedBonus * dt * 8;
      player.facing = 1;
    }

    if (!moveLeft && !moveRight) {
      player.vx *= 0.85;
    }

    player.vx = clamp(player.vx, -maxVelX * speedBonus, maxVelX * speedBonus);

    if (wantJump && player.onGround) {
      player.vy = jumpVel * jumpBonus;
      player.onGround = false;
      playSound('jump');
      createParticle(player.x + player.w / 2, player.y + player.h, '#7be2ff', 6);
    }

    if (wantShoot && player.shootCooldown <= 0) {
      lasers.push({
        x: player.x + (player.facing > 0 ? player.w : 0),
        y: player.y + player.h / 2 - 2,
        w: 20, h: 4,
        vx: player.facing * 500,
        dir: player.facing,
        damage: 1 + permanentUpgrades.damage
      });
      player.shootCooldown = 0.3;
      playSound('shoot');
      createParticle(player.x + player.w / 2, player.y + player.h / 2, player.facing > 0 ? '#ff3333' : '#3333ff', 4);
    }
    wantShoot = false;

    player.vy += gravity * dt;
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // Collision with platforms
    player.onGround = false;
    for (const segment of segments) {
      for (const plat of segment.platforms) {
        if (rectsOverlap(player.x, player.y, player.w, player.h, plat.x, plat.y, plat.w, plat.h)) {
          if (player.vy > 0 && player.y + player.h - player.vy * dt < plat.y + 10) {
            player.y = plat.y - player.h;
            player.vy = 0;
            player.onGround = true;
          } else if (player.vy < 0 && player.y - player.vy * dt > plat.y + plat.h - 10) {
            player.y = plat.y + plat.h;
            player.vy = 0;
          }
        }
      }
    }

    if (player.y > canvas.height + 100) loseLife();

    camera.x = player.x - canvas.width / 3;
    camera.x = Math.max(0, camera.x);

    // Load new segments
    if (player.x > nextSegmentX - canvas.width * 2 && !boss) {
      if (segmentsInLevel >= segmentsPerLevel) {
        spawnBoss();
      } else {
        loadNextSegment();
      }
    }

    unloadOldSegments();

    // Check level goal
    if (levelGoal && rectsOverlap(player.x, player.y, player.w, player.h, levelGoal.x, levelGoal.y, levelGoal.w, levelGoal.h)) {
      levelGoal = null; // Prevent re-trigger
      // Goal just triggers boss intro
    }

    // Update lasers
    for (let i = lasers.length - 1; i >= 0; i--) {
      const laser = lasers[i];
      laser.x += laser.vx * dt;
      if (laser.vy !== undefined) laser.y += laser.vy * dt;

      if (laser.x < camera.x - 100 || laser.x > camera.x + canvas.width + 100) {
        lasers.splice(i, 1);
        continue;
      }

      // Boss projectiles hit player
      if (laser.isBossProjectile) {
        if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, laser.x, laser.y, laser.w, laser.h)) {
          lasers.splice(i, 1);
          loseLife();
        }
        continue;
      }

      // Player lasers hit enemies
      for (const segment of segments) {
        for (let j = segment.enemies.length - 1; j >= 0; j--) {
          const enemy = segment.enemies[j];
          if (rectsOverlap(laser.x, laser.y, laser.w, laser.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
            const damage = laser.damage || 1;
            enemy.health -= damage;
            lasers.splice(i, 1);
            createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#ff5555', 10);
            createDamageNumber(enemy.x + enemy.w / 2, enemy.y - 10, damage);
            playSound('hit', 0.1);
            vibrate(20); // Haptic feedback for hitting enemy
            score += 10 * damage;
            addCombo();

            if (enemy.health <= 0) {
              segment.enemies.splice(j, 1);
              score += 50 + player.combo * 5;
              createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#FFD700', 20);
              playSound('stomp');
              vibrate(40); // Haptic feedback for defeating enemy
            }
            break;
          }
        }
      }

      // Player lasers hit boss (full hitbox including tentacles)
      if (boss) {
        // Boss hitbox includes entire body and tentacles
        const bossHitboxY = boss.y;
        const bossHitboxHeight = boss.h + 75; // Include tentacles (3 segments * 25px each)

        if (rectsOverlap(laser.x, laser.y, laser.w, laser.h, boss.x, bossHitboxY, boss.w, bossHitboxHeight)) {
          const damage = laser.damage || 1;
          boss.health -= damage;
          boss.hitFlash = 1.0;
          lasers.splice(i, 1);
          createParticle(boss.x + boss.w / 2, boss.y + boss.h / 2, '#ff5555', 15);
          createDamageNumber(boss.x + boss.w / 2, boss.y - 20, damage, '#ff5555');
          playSound('hit', 0.12);
          vibrate(30); // Haptic feedback on boss hit
          score += 20 * damage;
          shake.intensity = 8;
          addCombo();

          if (boss.health <= 0) {
            score += 500 + currentLevel * 100;
            player.sessionCoins += 50 + currentLevel * 10;
            createParticle(boss.x + boss.w / 2, boss.y + boss.h / 2, '#FFD700', 50, 12);
            shake.intensity = 30;
            vibrate([50, 50, 50]); // Haptic feedback on boss defeat
            boss = null;
            completeLevel();
          }
        }
      }
    }

    // Update enemies
    for (const segment of segments) {
      for (let i = segment.enemies.length - 1; i >= 0; i--) {
        const enemy = segment.enemies[i];
        enemy.animTimer += dt;

        if (enemy.type === 'hopper') {
          enemy.jumpTimer -= dt;
          if (enemy.jumpTimer <= 0 && enemy.vy === 0) {
            enemy.vy = -600;
            enemy.jumpTimer = rand(1.5, 3.0);
          }
          enemy.vy += gravity * dt;
          enemy.y += enemy.vy * dt;
          enemy.x += enemy.dir * enemy.vx * dt;

          for (const plat of segment.platforms) {
            if (rectsOverlap(enemy.x, enemy.y, enemy.w, enemy.h, plat.x, plat.y, plat.w, plat.h)) {
              if (enemy.vy > 0) {
                enemy.y = plat.y - enemy.h;
                enemy.vy = 0;
              }
            }
          }
        } else if (enemy.type === 'walker') {
          enemy.x += enemy.dir * enemy.vx * dt;
          enemy.rotateAngle += 0.15 * enemy.dir;

          if (enemy.x < segment.startX || enemy.x > segment.startX + segment.width) {
            enemy.dir *= -1;
          }
        } else if (enemy.type === 'flyer') {
          enemy.x += enemy.dir * enemy.vx * dt;
          enemy.bobT += 0.08;
          enemy.flapTimer += 0.2;

          if (enemy.x < camera.x - 50 || enemy.x > camera.x + canvas.width + 50) {
            enemy.dir *= -1;
          }
        }

        if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
          if (player.vy > 0 && player.y + player.h * 0.6 < enemy.y + enemy.h / 2) {
            enemy.health--;
            player.vy = jumpVel * 0.6;
            createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#FFD700', 12);
            createDamageNumber(enemy.x + enemy.w / 2, enemy.y - 10, 1);
            playSound('stomp');
            score += 100;
            addCombo();

            if (enemy.health <= 0) {
              segment.enemies.splice(i, 1);
              createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#FFD700', 20);
            }
          } else {
            loseLife();
          }
        }
      }
    }

    // Update coins
    for (const segment of segments) {
      for (let i = segment.coins.length - 1; i >= 0; i--) {
        const coin = segment.coins[i];
        coin.sparkleT += dt * 8;

        if (rectsOverlap(player.x, player.y, player.w, player.h, coin.x - coin.size, coin.y - coin.size, coin.size * 2, coin.size * 2)) {
          segment.coins.splice(i, 1);
          const coinValue = coin.value * (1 + permanentUpgrades.coinMultiplier * 0.5);
          player.sessionCoins += coinValue;
          score += 10 * coinValue;
          createParticle(coin.x, coin.y, '#FFD700', 8);
          createDamageNumber(coin.x, coin.y - 20, `+${Math.floor(coinValue)}`, '#FFD700');
          playSound('coin', 0.08);
        }
      }
    }

    // Update boss
    if (boss) {
      updateBoss(dt);
    }
  }

  // ============ DRAWING ============
  function draw() {
    ctx.save();
    ctx.translate(shake.x, shake.y);

    // Background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const layer of bgLayers) {
      for (const star of layer.elements) {
        const parallaxX = star.x - camera.x * layer.speed;

        if (parallaxX > -50 && parallaxX < canvas.width + 50) {
          star.twinkle += star.twinkleSpeed * 0.05;
          const alpha = 0.3 + Math.sin(star.twinkle) * 0.2;

          ctx.globalAlpha = alpha;
          ctx.fillStyle = layer.color;
          ctx.fillRect(parallaxX, star.y, star.size, star.size);
        }
      }
    }
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // Draw platforms with path indicators
    for (const segment of segments) {
      for (const plat of segment.platforms) {
        if (plat.type === 'ground') {
          ctx.fillStyle = '#2a313c';
          ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
          ctx.fillStyle = '#1b1f26';
          ctx.fillRect(plat.x, plat.y + 20, plat.w, plat.h - 20);
        } else {
          // Color platforms by path
          const pathColors = ['#3a5570', '#5a6580', '#7a8590'];
          ctx.fillStyle = pathColors[plat.path] || '#3a5570';
          ctx.strokeStyle = '#2a4050';
          ctx.lineWidth = 2;
          roundRect(plat.x, plat.y, plat.w, plat.h, 4, true, true);

          // High path indicator
          if (plat.path === 2) {
            ctx.fillStyle = '#FFD700';
            ctx.globalAlpha = 0.3;
            ctx.fillRect(plat.x, plat.y - 3, plat.w, 3);
            ctx.globalAlpha = 1;
          }
        }
      }
    }

    // Draw coins
    for (const segment of segments) {
      for (const coin of segment.coins) {
        ctx.save();
        ctx.translate(coin.x, coin.y);

        const pulse = 1 + Math.sin(coin.sparkleT) * 0.1;
        ctx.scale(pulse, pulse);

        ctx.fillStyle = coin.value > 1 ? '#FFD700' : '#FFA500';
        ctx.strokeStyle = '#FF8C00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        if (coin.value > 1) {
          ctx.fillStyle = '#FFF';
          ctx.font = 'bold 10px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('√ó2', 0, 0);
        }

        ctx.restore();
      }
    }

    // Draw level goal
    if (levelGoal) {
      ctx.save();
      ctx.translate(levelGoal.x, levelGoal.y);

      ctx.fillStyle = '#9fb1cc';
      ctx.fillRect(5, 0, 8, levelGoal.h);

      const wave = Math.sin(time * 4);
      ctx.fillStyle = '#7be2ff';
      ctx.strokeStyle = '#5bc0de';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(13, 10);
      ctx.quadraticCurveTo(35 + wave * 5, 25, 50, 30);
      ctx.lineTo(13, 40);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }

    // Draw enemies
    for (const segment of segments) {
      for (const enemy of segment.enemies) {
        ctx.save();
        ctx.translate(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2);

        if (enemy.type === 'hopper') {
          const squish = enemy.vy !== 0 ? (enemy.vy > 0 ? 0.9 : 1.1) : (1 + Math.sin(enemy.animTimer) * 0.05);
          ctx.scale(1, squish);
          ctx.fillStyle = '#c9d0da';
          ctx.strokeStyle = '#8ea0b5';
          ctx.lineWidth = 2;
          roundRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h, 8, true, true);
        } else if (enemy.type === 'walker') {
          ctx.rotate(enemy.rotateAngle);
          ctx.fillStyle = '#a890d0';
          ctx.strokeStyle = '#7860a0';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, enemy.w / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else if (enemy.type === 'flyer') {
          const wobble = Math.sin(enemy.bobT) * 3;
          ctx.translate(0, wobble);
          ctx.fillStyle = '#7895b8';
          ctx.strokeStyle = '#4a5f7a';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(0, 0, enemy.w / 2, enemy.h / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }

        // Health bar
        if (enemy.health < enemy.maxHealth) {
          ctx.resetTransform();
          ctx.translate(-camera.x, -camera.y);
          const barW = enemy.w;
          const barH = 4;
          const barX = enemy.x;
          const barY = enemy.y - 10;

          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          roundRect(barX, barY, barW, barH, 2, true, false);

          const healthPercent = enemy.health / enemy.maxHealth;
          ctx.fillStyle = healthPercent > 0.5 ? '#5bc0de' : '#ff5555';
          roundRect(barX + 1, barY + 1, (barW - 2) * healthPercent, barH - 2, 1, true, false);
        }

        ctx.restore();
      }
    }

    // Draw boss - ALIEN SQUID
    if (boss) {
      ctx.save();

      if (boss.hitFlash > 0) {
        ctx.globalAlpha = 0.5 + Math.sin(time * 50) * 0.5;
      }

      // Boss glow based on phase
      const glowColors = ['#8a2be2', '#ff1493', '#00ff00'];
      const bodyColors = ['#6a1fb2', '#9932cc', '#8b008b'];
      ctx.shadowColor = glowColors[boss.phase];
      ctx.shadowBlur = 25 + Math.sin(boss.animTimer * 3) * 8;

      // Tentacles (8 animated tentacles)
      const tentacleCount = 8;
      for (let i = 0; i < tentacleCount; i++) {
        const angle = (Math.PI * 2 * i) / tentacleCount;
        const tentacleWave = Math.sin(boss.animTimer * 4 + i) * 15;

        ctx.strokeStyle = bodyColors[boss.phase];
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';

        ctx.beginPath();
        const startX = boss.x + boss.w / 2 + Math.cos(angle) * (boss.w * 0.3);
        const startY = boss.y + boss.h * 0.7 + Math.sin(angle) * (boss.h * 0.2);
        ctx.moveTo(startX, startY);

        // Wavy tentacle
        for (let j = 1; j <= 3; j++) {
          const segmentX = startX + Math.cos(angle) * j * 20 + Math.sin(boss.animTimer * 3 + i + j) * tentacleWave;
          const segmentY = startY + j * 25 + Math.cos(boss.animTimer * 3 + i + j) * 10;
          ctx.lineTo(segmentX, segmentY);
        }
        ctx.stroke();

        // Tentacle suckers
        ctx.fillStyle = glowColors[boss.phase];
        for (let j = 1; j <= 3; j++) {
          const segmentX = startX + Math.cos(angle) * j * 20 + Math.sin(boss.animTimer * 3 + i + j) * tentacleWave;
          const segmentY = startY + j * 25 + Math.cos(boss.animTimer * 3 + i + j) * 10;
          ctx.beginPath();
          ctx.arc(segmentX, segmentY, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Main body (squid head/mantle)
      const bodyPulse = 1 + Math.sin(boss.animTimer * 2) * 0.08;
      ctx.fillStyle = bodyColors[boss.phase];
      ctx.strokeStyle = glowColors[boss.phase];
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.ellipse(boss.x + boss.w / 2, boss.y + boss.h * 0.35, boss.w * 0.45 * bodyPulse, boss.h * 0.4 * bodyPulse, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Alien markings on body
      ctx.fillStyle = glowColors[boss.phase];
      ctx.globalAlpha = 0.5;
      for (let i = 0; i < 5; i++) {
        const markX = boss.x + boss.w * (0.3 + i * 0.1);
        const markY = boss.y + boss.h * 0.35 + Math.sin(boss.animTimer * 3 + i) * 5;
        ctx.beginPath();
        ctx.arc(markX, markY, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = boss.hitFlash > 0 ? (0.5 + Math.sin(time * 50) * 0.5) : 1;

      // Eyes (three alien eyes)
      ctx.shadowBlur = 15;
      ctx.shadowColor = glowColors[boss.phase];

      const eyeY = boss.y + boss.h * 0.25;
      const eyePositions = [
        { x: boss.x + boss.w * 0.35, size: 10 },
        { x: boss.x + boss.w * 0.5, size: 12 },
        { x: boss.x + boss.w * 0.65, size: 10 }
      ];

      for (const eye of eyePositions) {
        // Eye white
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(eye.x, eyeY, eye.size, 0, Math.PI * 2);
        ctx.fill();

        // Pupil (follows player if charging)
        const pupilColor = boss.state === 'charging' ? '#ff0000' : glowColors[boss.phase];
        ctx.fillStyle = pupilColor;
        const pupilSize = eye.size * 0.6;
        ctx.beginPath();
        ctx.arc(eye.x, eyeY, pupilSize, 0, Math.PI * 2);
        ctx.fill();

        // Pupil highlight
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(eye.x - pupilSize * 0.3, eyeY - pupilSize * 0.3, pupilSize * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.shadowBlur = 0;

      // Health bar
      const barW = boss.w;
      const barH = 8;
      const barX = boss.x;
      const barY = boss.y - 25;

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      roundRect(barX, barY, barW, barH, 4, true, false);

      const healthPercent = boss.health / boss.maxHealth;
      ctx.fillStyle = healthPercent > 0.5 ? '#5bc0de' : '#ff5555';
      roundRect(barX + 2, barY + 2, (barW - 4) * healthPercent, barH - 4, 3, true, false);

      // Boss name
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 4;
      ctx.fillText(`ALIEN SQUID - Phase ${boss.phase + 1}`, boss.x + boss.w / 2, barY - 8);

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Draw lasers
    for (const laser of lasers) {
      if (laser.isBossProjectile) {
        ctx.fillStyle = '#ff5555';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(laser.x, laser.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      } else {
        ctx.fillStyle = laser.dir > 0 ? '#ff3333' : '#3333ff';
        roundRect(laser.x, laser.y, laser.w, laser.h, 2, true, false);
      }
    }

    // Draw player
    ctx.save();
    ctx.translate(player.x + player.w / 2, player.y + player.h / 2);

    if (player.invincible) {
      ctx.globalAlpha = 0.5 + Math.sin(time * 20) * 0.5;
    }

    ctx.scale(player.facing, 1);
    ctx.translate(-player.w / 2, -player.h / 2);

    let bodyOffset = 0;
    if (player.animState === 'walk') {
      bodyOffset = Math.sin(player.animFrame * Math.PI) * 2;
    }

    ctx.fillStyle = '#aeb7c4';
    ctx.strokeStyle = '#738096';
    ctx.lineWidth = 2;
    roundRect(4, 6 + bodyOffset, player.w - 8, player.h - 14, 10, true, true);

    ctx.fillStyle = '#8c97a7';
    roundRect(2, player.h - 12, player.w * 0.42, 12, 6, true, false);
    roundRect(player.w - player.w * 0.42 - 2, player.h - 12, player.w * 0.42, 12, 6, true, false);

    const earW = player.w * 0.2, earH = player.h * 0.7;
    ctx.fillStyle = '#aeb7c4';
    roundRect(player.w * 0.2, -earH * 0.4, earW, earH, 8, true, true);
    roundRect(player.w * 0.6, -earH * 0.3, earW, earH, 8, true, true);

    ctx.fillStyle = '#0d131a';
    roundRect(player.w * 0.25, player.h * 0.35 + bodyOffset, player.w * 0.5, player.h * 0.18, 8, true, false);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = '#7be2ff';
    roundRect(player.w * 0.3, player.h * 0.4 + bodyOffset, player.w * 0.4, player.h * 0.08, 5, true, false);
    ctx.globalCompositeOperation = 'source-over';

    ctx.globalAlpha = 1;
    ctx.restore();

    // Draw particles
    for (const p of particles) {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    }
    ctx.globalAlpha = 1;

    // Draw damage numbers
    for (const dn of damageNumbers) {
      ctx.globalAlpha = dn.life;
      ctx.fillStyle = dn.color;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.strokeText(dn.value, dn.x, dn.y);
      ctx.fillText(dn.value, dn.x, dn.y);
    }
    ctx.globalAlpha = 1;

    ctx.restore();
    ctx.restore();

    // Draw UI overlays
    if (gameState === 'bossIntro') {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#ff5555';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 20;
      ctx.fillText('BOSS APPROACHING', canvas.width / 2, canvas.height / 2);
      ctx.shadowBlur = 0;
    } else if (gameState === 'levelComplete') {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 56px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#FFA500';
      ctx.shadowBlur = 20;
      ctx.fillText(`LEVEL ${currentLevel} COMPLETE!`, canvas.width / 2, canvas.height / 2 - 80);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#9fb1cc';
      ctx.font = '20px sans-serif';
      ctx.fillText(`Coins Earned: ${player.sessionCoins}`, canvas.width / 2, canvas.height / 2 - 20);
      ctx.fillText(`Score: ${Math.floor(score)}`, canvas.width / 2, canvas.height / 2 + 10);

      ctx.fillStyle = '#7be2ff';
      ctx.font = 'bold 24px sans-serif';
      ctx.fillText('Press ENTER for Next Level', canvas.width / 2, canvas.height / 2 + 80);

      ctx.fillStyle = '#FFD700';
      ctx.font = '16px sans-serif';
      ctx.fillText('(Shop coming soon!)', canvas.width / 2, canvas.height / 2 + 110);
    } else if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#ff5555';
      ctx.font = 'bold 56px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);

      ctx.fillStyle = '#9fb1cc';
      ctx.font = '20px sans-serif';
      ctx.fillText(`Level Reached: ${currentLevel}`, canvas.width / 2, canvas.height / 2 - 10);
      ctx.fillText(`Score: ${Math.floor(score)}`, canvas.width / 2, canvas.height / 2 + 20);
      ctx.fillText(`Total Coins: ${totalCoins}`, canvas.width / 2, canvas.height / 2 + 50);

      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 24px sans-serif';
      ctx.fillText('Press R to Restart', canvas.width / 2, canvas.height / 2 + 100);
    } else if (paused) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#7be2ff';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);

      ctx.fillStyle = '#9fb1cc';
      ctx.font = '18px sans-serif';
      ctx.fillText('Press ESC to Resume', canvas.width / 2, canvas.height / 2 + 40);
    }
  }

  // ============ INPUT HANDLERS ============
  window.addEventListener('keydown', (e) => {
    if (['Space','ArrowUp','ArrowLeft','ArrowRight','Escape','KeyM','KeyX','KeyR','Enter'].includes(e.code)) e.preventDefault();

    if (e.code === 'Escape') {
      if (gameState === 'playing' || gameState === 'bossIntro') {
        paused = !paused;
        if (paused) pauseMusic();
        else resumeMusic();
      }
      return;
    }

    if (e.code === 'KeyM') {
      soundEnabled = !soundEnabled;
      if (!soundEnabled) {
        pauseMusic();
      } else {
        // Resume the current track that should be playing
        resumeMusic();
      }
      return;
    }

    if (e.code === 'KeyR' && gameState === 'gameOver') {
      location.reload();
      return;
    }

    if (e.code === 'Enter' && gameState === 'levelComplete') {
      startNextLevel();
      return;
    }

    if (gameState === 'playing' && !paused) {
      keys[e.code] = true;
      if (e.code === 'KeyX') wantShoot = true;
    }
  });

  window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });

  // ============ MOBILE CONTROLS ============
  const mobileButtons = {
    left: document.getElementById('mobile-left'),
    right: document.getElementById('mobile-right'),
    jump: document.getElementById('mobile-jump'),
    shoot: document.getElementById('mobile-shoot')
  };

  function handleTouchStart(btn, keyCode) {
    return (e) => {
      e.preventDefault();
      btn.classList.add('pressed');
      if (gameState === 'playing' && !paused && gameStarted) {
        keys[keyCode] = true;
        if (keyCode === 'KeyX') {
          wantShoot = true;
        }
      }
    };
  }

  function handleTouchEnd(btn, keyCode) {
    return (e) => {
      e.preventDefault();
      btn.classList.remove('pressed');
      keys[keyCode] = false;
    };
  }

  // Set up mobile button listeners
  mobileButtons.left.addEventListener('touchstart', handleTouchStart(mobileButtons.left, 'ArrowLeft'));
  mobileButtons.left.addEventListener('touchend', handleTouchEnd(mobileButtons.left, 'ArrowLeft'));
  mobileButtons.left.addEventListener('touchcancel', handleTouchEnd(mobileButtons.left, 'ArrowLeft'));

  mobileButtons.right.addEventListener('touchstart', handleTouchStart(mobileButtons.right, 'ArrowRight'));
  mobileButtons.right.addEventListener('touchend', handleTouchEnd(mobileButtons.right, 'ArrowRight'));
  mobileButtons.right.addEventListener('touchcancel', handleTouchEnd(mobileButtons.right, 'ArrowRight'));

  mobileButtons.jump.addEventListener('touchstart', handleTouchStart(mobileButtons.jump, 'Space'));
  mobileButtons.jump.addEventListener('touchend', handleTouchEnd(mobileButtons.jump, 'Space'));
  mobileButtons.jump.addEventListener('touchcancel', handleTouchEnd(mobileButtons.jump, 'Space'));

  mobileButtons.shoot.addEventListener('touchstart', handleTouchStart(mobileButtons.shoot, 'KeyX'));
  mobileButtons.shoot.addEventListener('touchend', handleTouchEnd(mobileButtons.shoot, 'KeyX'));
  mobileButtons.shoot.addEventListener('touchcancel', handleTouchEnd(mobileButtons.shoot, 'KeyX'));

  // Prevent scrolling/zooming on mobile
  document.body.addEventListener('touchmove', (e) => {
    if (gameStarted && e.target === canvas) {
      e.preventDefault();
    }
  }, { passive: false });

  // ============ GAME LOOP ============
  let last = performance.now();
  function loop(now) {
    const rawDt = (now - last) / 1000;
    last = now;
    const dt = Math.min(1 / 30, rawDt);

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ============ START SCREEN ============
  const startScreen = document.getElementById('start-screen');

  function startGame() {
    if (!gameStarted) {
      gameStarted = true;
      startScreen.classList.add('hidden');

      // Resume audio context (required by some browsers)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // Start music with proper user interaction
      playMusic('level');
    }
  }

  startScreen.addEventListener('click', startGame);
  startScreen.addEventListener('touchstart', (e) => {
    e.preventDefault();
    startGame();
  });

  // ============ INITIALIZATION ============
  initBackground();
  for (let i = 0; i < 3; i++) {
    loadNextSegment();
  }
  updateHUD();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
