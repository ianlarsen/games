<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Robot Bunny On The Moon</title>
<style>
  :root {
    --bg-deep: #000000;
  }
  html, body { height: 100%; margin: 0; background: var(--bg-deep); color: #e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
  #wrap { display: grid; place-items: center; height: 100%; }
  canvas {
    background: #000;
    width: min(100vw, 960px);
    height: min(62vh, 560px);
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0,0,0,.45);
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  @media (max-width: 768px), (pointer: coarse) {
    canvas {
      width: 100vw;
      height: calc(100vh - 200px);
      border-radius: 0;
      max-height: 600px;
    }
  }
  .hud {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
    font-weight: 650; letter-spacing: .2px; text-shadow: 0 0 8px rgba(123,226,255,.15);
    font-size: 13px; max-width: 90vw;
  }
  .hud-item { display: flex; align-items: center; gap: 5px; padding: 3px 8px; background: rgba(16,22,32,0.85); border-radius: 5px; border: 1px solid rgba(123,226,255,0.25); }
  .combo-display {
    position: fixed; top: 100px; right: 20px;
    font-size: 32px; font-weight: 900; color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.4);
    animation: pulse 0.5s ease-in-out infinite alternate;
    display: none;
  }
  .combo-display.active { display: block; }
  @media (max-width: 768px), (pointer: coarse) {
    .combo-display { top: 60px; right: 10px; font-size: 24px; }
  }
  @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.1); } }
  .hint { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); opacity: .8; font-size: 12px; color: #9fb1cc; text-align: center; max-width: 90vw; }
  .badge { position: fixed; top: 10px; right: 14px; font-size: 11px; color: #9fb1cc; opacity: .8; }
  @media (max-width: 768px), (pointer: coarse) {
    .hint { bottom: 200px; font-size: 11px; }
    .badge { display: none; }
  }
  .start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center;
    flex-direction: column; gap: 30px;
    z-index: 1000; cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  .start-screen.hidden { display: none; }
  .start-title {
    font-size: 48px; font-weight: 900;
    font-family: 'Impact', 'Arial Black', sans-serif;
    letter-spacing: 4px;
    text-align: center; padding: 0 20px;
    color: #b0b8c0;
    background: linear-gradient(180deg, #e8eef4 0%, #8090a0 50%, #4a5560 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  }
  .start-button {
    padding: 20px 60px; font-size: 28px; font-weight: bold; color: #7be2ff;
    background: rgba(123,226,255,0.1); border: 3px solid #7be2ff; border-radius: 15px;
    cursor: pointer; transition: all 0.3s;
    user-select: none; -webkit-user-select: none;
    touch-action: manipulation;
    min-width: 250px; text-align: center;
  }
  .start-button:hover, .start-button:active {
    background: rgba(123,226,255,0.2); box-shadow: 0 0 20px rgba(123,226,255,0.5);
    transform: scale(1.05);
  }
  #loading-text { color: #7be2ff; font-family: sans-serif; font-weight: bold; }

  /* Mobile Controls */
  .mobile-controls {
    position: fixed; bottom: 0; left: 0; width: 100%; height: 180px;
    display: none; pointer-events: none; z-index: 100;
  }
  @media (max-width: 768px), (pointer: coarse) {
    .mobile-controls { display: block; }
    .hud { top: 5px; font-size: 11px; gap: 5px; }
    .hud-item { padding: 2px 6px; }
  }
  .mobile-btn {
    position: absolute; background: rgba(123, 226, 255, 0.2);
    border: 3px solid rgba(123, 226, 255, 0.5); border-radius: 50%;
    color: #7be2ff; font-size: 24px; display: flex; align-items: center; justify-content: center;
    font-weight: bold; user-select: none; -webkit-user-select: none; touch-action: none;
    pointer-events: auto; -webkit-tap-highlight-color: transparent;
    box-shadow: 0 0 15px rgba(123, 226, 255, 0.3);
  }
  .mobile-btn:active { background: rgba(123, 226, 255, 0.3); transform: scale(0.95); }
  #mobile-left { left: 15px; bottom: 15px; width: 80px; height: 80px; }
  #mobile-right { left: 110px; bottom: 15px; width: 80px; height: 80px; }
  #mobile-jump { right: 110px; bottom: 15px; width: 90px; height: 90px; font-size: 16px; }
  #mobile-shoot { right: 15px; bottom: 15px; width: 80px; height: 80px; font-size: 28px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="560" aria-label="Robot Bunny Platformer"></canvas>
</div>
<div class="hud">
  <div class="hud-item"><span>üåô</span><span id="level">Level 1</span></div>
  <div class="hud-item"><span>‚ù§Ô∏è</span><span id="lives">√ó3</span></div>
  <div class="hud-item"><span>üéØ</span><span id="score">0</span></div>
  <div class="hud-item"><span>ü™ô</span><span id="coins">0</span></div>
  <div class="hud-item"><span>‚≠ê</span><span id="upgrades">Upgrades: 0</span></div>
</div>
<div class="combo-display" id="combo-display">COMBO √ó0</div>
<div class="hint" id="hint-text">Move: ‚Üê‚Üí ‚Ä¢ Jump: Space ‚Ä¢ Shoot: X ‚Ä¢ Pause: ESC</div>
<div class="badge">Image Edition</div>

<!-- Start Screen -->
<div class="start-screen" id="start-screen">
  <canvas id="start-bunny-canvas" width="100" height="100"></canvas>
  <div class="start-title" id="start-title">ROBOT BUNNY</div>
  <div class="start-button" id="start-btn" style="display:none;">TAP TO START</div>
  <div id="loading-text">LOADING ASSETS... 0%</div>
</div>

<div class="mobile-controls">
  <div class="mobile-btn" id="mobile-left">‚Üê</div>
  <div class="mobile-btn" id="mobile-right">‚Üí</div>
  <div class="mobile-btn" id="mobile-jump">JUMP</div>
  <div class="mobile-btn" id="mobile-shoot">‚ú¶</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  let audioCtx; // created on first user gesture
  let currentMusic = null;

  // ============ ASSET LOADING ============
  const assets = {};
  const imageSources = {
    player: 'images/robotbunny.png',
    bg: 'images/moon-background.png',
    ground: 'images/ground.png',
    platform: 'images/platform.png',
    hopper: 'images/hopper.png',
    flyer: 'images/flyer.png',
    heart: 'images/heart.png',
    coin: 'images/coin.png',
    // Bosses
    squid: 'images/squid.png',
    squid_armor: 'images/squid_armor.png',
    squid_armor_spike: 'images/squid_armor_spike.png',
    mantis: 'images/mantis.png',
    mantis_armor: 'images/mantis_armor.png',
    mantis_armor_spike: 'images/mantis_armor_spike.png',
    sal: 'images/sal.png',
    sal_armor: 'images/sal_armor.png',
    sal_armor_spike: 'images/sal_armor_spike.png',
    chimiera: 'images/chimiera.png'
    ,fireball: 'images/fireball.png'
    ,tank: 'images/tank.png'
    ,bg1: 'images/moon-background.png'
    ,bg2: 'images/mercury.png'
    ,bg3: 'images/venus.png'
    ,bg4: 'images/earth.png'
    ,bg5: 'images/mars.png'
    ,bg6: 'images/jupiter.png'
    ,bg7: 'images/saturn.png'
    ,bg8: 'images/uranus.png'
    ,bg9: 'images/neptune.png'
    ,bg10: 'images/pluto.png'
  };

  const soundSources = {
    level1: 'sounds/level1.mp3',
    level2: 'sounds/level2.mp3',
    level3: 'sounds/level3.mp3',
    level4: 'sounds/level4.mp3',
    level5: 'sounds/level5.mp3',
    level6: 'sounds/level6.mp3',
    level7: 'sounds/level7.mp3',
    level8: 'sounds/level8.mp3',
    level9: 'sounds/level9.mp3',
    level10: 'sounds/level10.mp3',
    boss: 'sounds/boss.mp3',
    victory: 'sounds/victory.mp3'
    ,
    // SFX (added)
    life: 'sounds/life.mp3',
    jump: 'sounds/jump.mp3',
    laser: 'sounds/laser.mp3',
    hit: 'sounds/hit.mp3',
    bossHit: 'sounds/boss-hit.mp3',
    coinCollect: 'sounds/coin.mp3',
    flag: 'sounds/flag.mp3',
    squish: 'sounds/squish.mp3'
    ,fireballSfx: 'sounds/fireball.mp3'
  };

  // Placeholder for test hopper insertion flag (not used in final version).

  let assetsToLoad = Object.keys(imageSources).length + Object.keys(soundSources).length;
  let assetsLoaded = 0;
  let gameReady = false;

  function assetLoaded() {
    assetsLoaded++;
    const percent = Math.floor((assetsLoaded / assetsToLoad) * 100);
    const loadingText = document.getElementById('loading-text');
    if (loadingText) loadingText.textContent = `LOADING ASSETS... ${percent}%`;

      if (assetsLoaded >= assetsToLoad) {
        gameReady = true;
        if (loadingText) loadingText.style.display = 'none';
        const startBtn = document.getElementById('start-btn');
        if (startBtn) startBtn.style.display = 'block';
        drawStartScreenBunny();
      }
  }

  function loadAssets() {
    // Images
    for (const [key, src] of Object.entries(imageSources)) {
      const img = new Image();
      img.onload = assetLoaded;
      img.onerror = () => { console.error('Failed to load image:', src); assetLoaded(); };
      assets[key] = img;
      img.src = src;
    }
    // Sounds
    for (const [key, src] of Object.entries(soundSources)) {
      const audio = new Audio();
      audio.preload = 'auto';
      audio.addEventListener('canplaythrough', assetLoaded, { once: true });
      audio.addEventListener('error', () => { console.error('Failed to load sound:', src); assetLoaded(); }, { once: true });
      assets[key] = audio;
      audio.src = src;
      // Some browsers require explicit load() for non-DOM-attached Audio
      try { audio.load(); } catch(e) {}
    }
  }

  function fit() {
    const maxW = Math.min(window.innerWidth, 960);
    const maxH = Math.min(window.innerHeight * 0.62, 560);
    const ar = canvas.width / canvas.height;
    let w = maxW, h = w / ar;
    if (h > maxH) { h = maxH; w = h * ar; }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', fit); fit();

  // ============ UTILITY FUNCTIONS ============
  function rand(a, b) { return a + Math.random() * (b - a); }
  function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
  }

  // ============ CONSTANTS ============
  const GROUND_Y = canvas.height - 80;
  const gravity = 2200;
  const jumpVel = -950;
  const moveSpeed = 250;
  const maxVelX = 350;

  // ============ GAME STATE ============
  let gameState = 'start'; // start, playing, bossIntro, levelComplete, gameOver
  let gameStarted = false;
  let time = 0;
  let score = 0;
  let currentLevel = 1;
  let segmentsInLevel = 0;
  const segmentsPerLevel = 4;
  let paused = false;
  let camera = { x: 0, y: 0 };
  let shake = { x: 0, y: 0, intensity: 0 };
  let bossIntroTimer = 0;
  // Track coins towards an extra life. Every 127 coins collected grants a bonus life
  // and the counter resets by subtracting 127. This allows accumulating multiple
  // extra lives if many coins are collected at once.
  let coinsForExtraLife = 0;
  // Difficulty scaling for bosses. After each boss defeat, this factor
  // increases by 20% (multiplicative), making subsequent bosses tougher.
  let bossDifficultyFactor = 1.0;

  // ============ PERSISTENT DATA ============
  let totalCoins = parseInt(localStorage.getItem('rb_endless_coins') || '0', 10);
  let highestLevel = parseInt(localStorage.getItem('rb_endless_highest') || '1', 10);
  let highScore = parseInt(localStorage.getItem('rb_high_score') || '0', 10);
  let loopNumber = 0;

  const permanentUpgrades = {
    maxHealth: parseInt(localStorage.getItem('rb_upg_health') || '5', 10),
  };

  function saveProgress() {
    localStorage.setItem('rb_endless_coins', totalCoins);
    localStorage.setItem('rb_endless_highest', highestLevel);
    localStorage.setItem('rb_high_score', highScore);
  }

  // ============ PLAYER ============
  const player = {
    x: 100, y: GROUND_Y - 72, w: 48, h: 64,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    shootCooldown: 0,
    invincible: false,
    invincibleTimer: 0,
    lives: permanentUpgrades.maxHealth,
    maxLives: permanentUpgrades.maxHealth,
    combo: 0,
    comboTimer: 0,
    sessionCoins: 0
  };

  // ============ INPUT ============
  const keys = {};
  let wantShoot = false;

  // ============ ENTITIES ============
  const lasers = [];
  const fireballs = [];
  const particles = [];
  const damageNumbers = [];
  const segments = [];
  let currentSegmentIndex = 0;
  let nextSegmentX = 0;
  let boss = null;
  let levelFlag = null;
  // Track whether a tank has been spawned in the current level. Resets when a new level starts.
  let tankSpawned = false;

  // ============ MUSIC FUNCTIONS (FIXED) ============
  function stopMusic() {
    if (currentMusic) {
      try { currentMusic.pause(); } catch(e) {}
      try { currentMusic.currentTime = 0; } catch(e) {}
      currentMusic = null;
    }
  }

  function playMusic(trackName) {
    // Start only after a user gesture; do not require audioCtx for HTMLAudio playback,
    // but create one if available to satisfy policies on some browsers.
    if (!audioCtx) {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch(e) { /* ignore */ }
    }
    stopMusic();
    const track = assets[trackName];
    if (track && typeof track.play === 'function') {
      track.loop = (trackName !== 'victory');
      track.currentTime = 0;
      // Ensure not muted by page visibility
      track.muted = false;
      track.play().catch(err => console.warn('Audio play was blocked:', err));
      currentMusic = track;
    } else {
      console.warn('Music track not found:', trackName);
    }
  }

  // ============ SFX HELPER ==========
  /**
   * Play a short sound effect. A clone of the original audio object is used so that
   * overlapping effects do not cut each other off. Provide a volume between 0 and 1.
   */
  function playSfx(name, vol = 1.0) {
    const audio = assets[name];
    if (!audio || typeof audio.cloneNode !== 'function') return;
    try {
      const instance = audio.cloneNode();
      instance.volume = vol;
      instance.play().catch(() => {});
    } catch (e) {
      // ignore playback errors
    }
  }

  // ============ PARTICLES ============
  function createParticle(x, y, color, count = 8, size = 5) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + rand(-0.3, 0.3);
      const speed = rand(100, 250);
      particles.push({
        x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - rand(50, 150),
        life: 1.0, decay: rand(1.5, 2.5), size: rand(3, size), color
      });
    }
  }
  function createDamageNumber(x, y, value, color = '#FFD700') {
    damageNumbers.push({ x, y: y - 10, value: value, life: 1.0, color: color, vy: -100 });
  }
  function addCombo() {
    player.combo++;
    player.comboTimer = 2.0;
    const display = document.getElementById('combo-display');
    if (display && player.combo >= 3) {
      display.textContent = `COMBO √ó${player.combo}`;
      display.classList.add('active');
    } else if (display) {
      display.classList.remove('active');
    }
  }
  function resetCombo() {
    player.combo = 0;
    const display = document.getElementById('combo-display');
    if (display) display.classList.remove('active');
  }

  // ============ LEVEL GENERATION ============
  function generateSegment(isLast = false) {
    const width = randInt(1400, 1800);
    const segment = {
      id: currentSegmentIndex,
      startX: nextSegmentX,
      width: width,
      platforms: [],
      enemies: [],
      coins: [],
      powerups: []
    };
    // Ground
    segment.platforms.push({ x: segment.startX, y: GROUND_Y, w: width, h: 200, type: 'ground' });

    const gapMax = 180;
    const platformCount = Math.floor(width / 200);
    let currentX = segment.startX + 150;
    let currentY = GROUND_Y - 100;

    for (let i = 0; i < platformCount; i++) {
      const gap = rand(100, gapMax);
      const platformW = randInt(120, 140);
      currentX += gap;
      currentY = clamp(currentY + rand(-50, 50), GROUND_Y - 300, GROUND_Y - 60);

      segment.platforms.push({ x: currentX, y: currentY, w: platformW, h: 40, type: 'platform' });

      // Enemies
      if (Math.random() < 0.4) {
        const enemyTypes = ['hopper', 'walker'];
        if (currentLevel >= 3) enemyTypes.push('flyer');
        const type = enemyTypes[randInt(0, enemyTypes.length - 1)];
        const enemy = {
          type,
          x: currentX + rand(10, platformW - 50),
          y: currentY - (type === 'flyer' ? 80 : 32),
          w: type === 'flyer' ? 60 : (type === 'walker' ? 35 : 40),
          h: type === 'flyer' ? 40 : 32,
          vx: type === 'walker' ? 80 : 100,
          vy: 0,
          health: 1 + Math.floor(currentLevel / 4),
          maxHealth: 1 + Math.floor(currentLevel / 4),
          dir: Math.random() > 0.5 ? 1 : -1,
          animTimer: 0,
          rotateAngle: 0,
          bobT: rand(0, Math.PI * 2),
          jumpTimer: type === 'hopper' ? rand(1, 3) : 0
        };
        segment.enemies.push(enemy);
      }

      // Coins
      if (Math.random() < 0.6) {
        const coinCount = randInt(1, 3);
        for (let c = 0; c < coinCount; c++) {
          segment.coins.push({
            x: currentX + rand(20, platformW - 40) + c * 35,
            y: currentY - rand(40, 90),
            size: 16,
            sparkleT: rand(0, Math.PI * 2),
            value: 1
          });
        }
      }
      // Powerups
      if (Math.random() < 0.08) {
        segment.powerups.push({ type: 'extraLife', x: currentX + rand(20, platformW - 40), y: currentY - rand(60, 100), w: 32, h: 32 });
      }
      currentX += platformW;
    }
    return segment;
  }

  function loadNextSegment() {
    segmentsInLevel++;
    const isLastBeforeBoss = segmentsInLevel >= segmentsPerLevel;
    const segment = generateSegment(isLastBeforeBoss);
    // Spawn a tank on level 4 if one hasn't been spawned yet. Position it toward
    // the end of this segment on the ground. Tanks have their own firing barrel.
    if (currentLevel === 4 && !tankSpawned) {
      const tW = 150;
      const tH = 80;
      // Place tank near the right side of the segment so the player encounters it.
      const tX = segment.startX + segment.width - 400;
      const tY = GROUND_Y - tH;
      const tankEnemy = {
        type: 'tank',
        x: tX,
        y: tY,
        w: tW,
        h: tH,
        vx: 0,
        vy: 0,
        health: 3,
        maxHealth: 3,
        dir: -1,
        animTimer: 0,
        fireCooldown: 3.0,
        barrelAngle: 0
      };
      segment.enemies.push(tankEnemy);
      tankSpawned = true;
    }
    segments.push(segment);
    nextSegmentX += segment.width;
    currentSegmentIndex++;
  }

  // Boss Configuration
  function getBossConfig(level) {
    const bossIndex = ((level - 1) % 10);
    let type = 'squid';
    let variation = 'plain';
    let name = 'ALIEN SQUID';
    let hpMult = 1.0;

    if (level % 10 === 0 || bossIndex === 9) {
      type = 'chimiera';
      name = 'ULTIMATE CHIMERA';
      hpMult = 2.0;
    } else {
      if (bossIndex === 1 || bossIndex === 4 || bossIndex === 7) { type = 'mantis'; name = 'SPACE MANTIS'; }
      if (bossIndex === 2 || bossIndex === 5 || bossIndex === 8) { type = 'sal'; name = 'LUNAR SALAMANDER'; }
      if (bossIndex >= 3 && bossIndex <= 5) { variation = 'armor'; name = 'ARMORED ' + name.split(' ')[1]; hpMult = 1.2; }
      if (bossIndex >= 6 && bossIndex <= 8) { variation = 'spike'; name = 'ARMORED SPIKED ' + name.split(' ')[1]; hpMult = 1.4; }
    }
    return { type, variation, name, hpMult };
  }

  function spawnBoss() {
    const config = getBossConfig(currentLevel);
    for (const seg of segments) seg.enemies = [];
    // Determine the boss size. All bosses are scaled uniformly relative to their base size.
    const bossSize = 180 * 2.2;
    // Compute the base fireball interval. After prior tuning the boss fired at
    // 30% of the original rate (roughly every 6.67s). We now want the boss
    // to fire twice as often as that adjusted rate (60% of the original rate),
    // which halves the interval. That yields roughly every 3.33s.
    const baseFireInterval = (2.0 / 0.3) / 2; // ‚âà 3.33 seconds per shot
    // Determine base health scaled by boss difficulty factor. A higher factor
    // makes bosses progressively harder each time one is defeated.
    const baseHealth = Math.floor(15 * config.hpMult);
    const scaledHealth = Math.floor(baseHealth * bossDifficultyFactor);
    boss = {
      x: nextSegmentX + 400,
      // Position the boss so its feet rest on the ground. The bottom of the boss (y + h)
      // should align with GROUND_Y.
      y: GROUND_Y - bossSize,
      w: bossSize,
      h: bossSize,
      fireCooldown: baseFireInterval,
      vx: 0,
      vy: 0,
      health: scaledHealth,
      maxHealth: scaledHealth,
      state: 'idle',
      stateTimer: 0,
      bossType: config.type,
      variation: config.variation,
      name: config.name,
      dir: -1,
      hitFlash: 0,
      animTimer: 0
    };
    gameState = 'bossIntro';
    bossIntroTimer = 0;
    playMusic('boss');
  }

  function unloadOldSegments() {
    while (segments.length > 0 && segments[0].startX + segments[0].width < camera.x - 500) {
      segments.shift();
    }
  }

  // ============ GAME LOGIC ============
  function loseLife() {
    player.lives--;
    resetCombo();
    if (player.lives <= 0) {
      gameState = 'gameOver';
      if (score > highScore) highScore = score;
      saveProgress();
      stopMusic();
      shake.intensity = 25;
    } else {
      player.x = camera.x + 100;
      player.y = GROUND_Y - player.h - 20;
      player.vx = 0; player.vy = 0;
      player.invincible = true; player.invincibleTimer = 2.5;
      shake.intensity = 18;
    }
  }

  function completeLevel() {
    gameState = 'levelComplete';
    stopMusic();
    playMusic('victory');
    totalCoins += player.sessionCoins;
    if (currentLevel > highestLevel) highestLevel = currentLevel;
    if (score > highScore) highScore = score;
    saveProgress();
  }

  function startNextLevel() {
    currentLevel++;
    if (currentLevel > 10) { currentLevel = 1; loopNumber++; }
    segmentsInLevel = 0;
    boss = null;
    levelFlag = null;
    segments.length = 0;
    lasers.length = 0;
    particles.length = 0;
    // Reset tank spawn flag at the start of each level
    tankSpawned = false;
    currentSegmentIndex = 0;
    nextSegmentX = 0;
    player.x = 100;
    player.y = GROUND_Y - player.h - 20;
    player.vx = 0; player.vy = 0;
    player.sessionCoins = 0;
    camera.x = 0;
    resetCombo();
    for (let i = 0; i < 3; i++) loadNextSegment();
    gameState = 'playing';
    playMusic(`level${currentLevel}`);
  }

  function updateHUD() {
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    if (levelEl) levelEl.textContent = `Level ${currentLevel}`;
    if (livesEl) livesEl.textContent = `√ó${player.lives}`;
    if (scoreEl) scoreEl.textContent = Math.floor(score);
    if (coinsEl) coinsEl.textContent = player.sessionCoins + totalCoins;
  }

  function update(dt) {
    if (paused || !gameStarted || gameState === 'start') return;
    time += dt;

    if (player.comboTimer > 0) {
      player.comboTimer -= dt;
      if (player.comboTimer <= 0) resetCombo();
    }

    if (gameState === 'playing') {
      updatePlaying(dt);
    } else if (gameState === 'bossIntro') {
      bossIntroTimer += dt;
      const targetCameraX = boss.x - 300;
      camera.x += (targetCameraX - camera.x) * (dt / 1.5);
      if (bossIntroTimer >= 1.5) gameState = 'playing';
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt; p.vy += gravity * 0.5 * dt;
      p.life -= p.decay * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
      const dn = damageNumbers[i];
      dn.y += dn.vy * dt; dn.life -= dt * 1.2;
      if (dn.life <= 0) damageNumbers.splice(i, 1);
    }

    shake.intensity = Math.max(0, shake.intensity - dt * 15);
    shake.x = (Math.random() - 0.5) * shake.intensity;
    shake.y = (Math.random() - 0.5) * shake.intensity;
    updateHUD();
  }

  function updatePlaying(dt) {
    if (player.invincibleTimer > 0) player.invincibleTimer -= dt;
    if (player.invincibleTimer <= 0) player.invincible = false;
    if (player.shootCooldown > 0) player.shootCooldown -= dt;

    const moveLeft = keys.ArrowLeft;
    const moveRight = keys.ArrowRight;
    const wantJump = keys.Space || keys.ArrowUp;

    if (moveLeft) { player.vx -= moveSpeed * dt * 8; player.facing = -1; }
    if (moveRight) { player.vx += moveSpeed * dt * 8; player.facing = 1; }
    if (!moveLeft && !moveRight) player.vx *= 0.85;

    player.vx = clamp(player.vx, -maxVelX, maxVelX);

    if (wantJump && player.onGround) {
      player.vy = jumpVel;
      player.onGround = false;
      // Play jump sound when the player jumps
      playSfx('jump', 0.7);
    }

    if (wantShoot && player.shootCooldown <= 0) {
      lasers.push({
        x: player.x + (player.facing > 0 ? player.w : 0),
        y: player.y + player.h / 2 - 2,
        w: 20, h: 4, vx: player.facing * 500, dir: player.facing
      });
      player.shootCooldown = 0.3;
      // Play shooting sound when firing a laser
      playSfx('laser', 0.6);
    }
    wantShoot = false;

    player.vy += gravity * dt;
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    player.onGround = false;
    for (const segment of segments) {
      for (const plat of segment.platforms) {
        if (rectsOverlap(player.x, player.y, player.w, player.h, plat.x, plat.y, plat.w, plat.h)) {
          if (player.vy > 0 && (player.y + player.h - player.vy * dt) <= plat.y) {
            player.y = plat.y - player.h; player.vy = 0; player.onGround = true;
          } else if (player.vy < 0 && (player.y - player.vy * dt) >= (plat.y + plat.h)) {
            player.y = plat.y + plat.h; player.vy = 0;
          }
        }
      }
    }

    if (player.y > canvas.height + 100) loseLife();

    camera.x = Math.max(0, player.x - canvas.width / 3);

    if (player.x > nextSegmentX - canvas.width * 2 && !boss && !levelFlag && gameState === 'playing') {
      if (segmentsInLevel >= segmentsPerLevel) spawnBoss();
      else loadNextSegment();
    }
    unloadOldSegments();

    if (levelFlag && rectsOverlap(player.x, player.y, player.w, player.h, levelFlag.x, levelFlag.y, levelFlag.w, levelFlag.h)) {
      // Play flag touch sound and complete the level
      playSfx('flag', 0.8);
      completeLevel();
    }

    for (let i = lasers.length - 1; i >= 0; i--) {
      const laser = lasers[i];
      laser.x += laser.vx * dt;
      if (laser.vy) laser.y += laser.vy * dt;
      if (laser.x < camera.x - 100 || laser.x > camera.x + canvas.width + 100) { lasers.splice(i, 1); continue; }

      for (const segment of segments) {
        for (let j = segment.enemies.length - 1; j >= 0; j--) {
          const enemy = segment.enemies[j];
          if (rectsOverlap(laser.x, laser.y, laser.w, laser.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
            enemy.health--;
            lasers.splice(i, 1);
            // Play sound when a laser hits an enemy
            playSfx('hit', 0.7);
            createParticle(enemy.x + enemy.w/2, enemy.y + enemy.h/2, '#fff', 5);
            createDamageNumber(enemy.x + enemy.w/2, enemy.y, 1);
            score += 10;
            addCombo();
            if (enemy.health <= 0) { segment.enemies.splice(j, 1); score += 50; }
            break;
          }
        }
      }
      if (boss && rectsOverlap(laser.x, laser.y, laser.w, laser.h, boss.x, boss.y, boss.w, boss.h)) {
        boss.health--; boss.hitFlash = 1.0; lasers.splice(i, 1);
        // Play sound when hitting the boss
        playSfx('bossHit', 0.8);
        createDamageNumber(boss.x + boss.w/2, boss.y, 1, '#ff5555');
        score += 20; addCombo();
        if (boss.health <= 0) {
          score += 1000;
          levelFlag = { x: boss.x + boss.w / 2 - 30, y: GROUND_Y - 120, w: 60, h: 100 };
          // Increase boss difficulty factor so the next boss has 20% more health.
          bossDifficultyFactor *= 1.2;
          boss = null;
        }
      } else {
        // Check collision with boss fireballs. If a laser hits a fireball, decrement the fireball's hp
        // and destroy it if hp runs out. The laser is always consumed.
        for (let fbIndex = fireballs.length - 1; fbIndex >= 0; fbIndex--) {
          const fb = fireballs[fbIndex];
          if (rectsOverlap(laser.x, laser.y, laser.w, laser.h, fb.x, fb.y, fb.w, fb.h)) {
            // Decrement fireball health (default 1 if missing). Remove the fireball when depleted.
            fb.hp = (fb.hp || 1) - 1;
            lasers.splice(i, 1);
            if (fb.hp <= 0) {
              fireballs.splice(fbIndex, 1);
            }
            // Play hit sound to indicate collision
            playSfx('hit', 0.7);
            // Stop checking other fireballs
            break;
          }
        }
      }
    }

    for (const segment of segments) {
      for (let i = segment.enemies.length - 1; i >= 0; i--) {
        const enemy = segment.enemies[i];
        enemy.animTimer += dt;
        if (enemy.type === 'hopper') {
          enemy.jumpTimer -= dt;
          if (enemy.jumpTimer <= 0 && enemy.vy === 0) { enemy.vy = -600; enemy.jumpTimer = rand(1.5, 3.0); }
          enemy.vy += gravity * dt; enemy.y += enemy.vy * dt;
          let onGround = false;
          for (const plat of segment.platforms) {
            if (rectsOverlap(enemy.x, enemy.y, enemy.w, enemy.h, plat.x, plat.y, plat.w, plat.h)) {
              if (enemy.vy > 0 && (enemy.y + enemy.h - enemy.vy*dt) <= plat.y) { enemy.y = plat.y - enemy.h; enemy.vy = 0; onGround = true; }
            }
          }
          if (!onGround) { enemy.x += enemy.dir * (enemy.vx * 0.5) * dt; }
        } else if (enemy.type === 'walker') {
          enemy.x += enemy.dir * enemy.vx * dt; enemy.rotateAngle += 0.15 * enemy.dir;
          if (enemy.x < segment.startX || enemy.x > segment.startX + segment.width - enemy.w) enemy.dir *= -1;
        } else if (enemy.type === 'flyer') {
          enemy.x += enemy.dir * enemy.vx * dt;
          if (enemy.x < camera.x || enemy.x > camera.x + canvas.width - enemy.w) enemy.dir *= -1;
        } else if (enemy.type === 'tank') {
          // Tanks remain stationary but aim their barrel at the player and fire. Compute a pivot
          // point on the tank for the barrel based on the tank‚Äôs position. Update the
          // barrel angle to point towards the player and spawn fireballs when cooldown expires.
          const pivotX = enemy.x + enemy.w * 0.5;
          const pivotY = enemy.y + enemy.h * 0.4;
          const playerCx = player.x + player.w * 0.5;
          const playerCy = player.y + player.h * 0.5;
          const dx = playerCx - pivotX;
          const dy = playerCy - pivotY;
          enemy.barrelAngle = Math.atan2(dy, dx);
          enemy.fireCooldown -= dt;
          if (enemy.fireCooldown <= 0) {
            // Determine the spawn position at the tip of the barrel. Use 60% of the tank width as barrel length.
            const barrelLen = enemy.w * 0.6;
            const fbW = 40;
            const fbH = 40;
            const spawnX = pivotX + Math.cos(enemy.barrelAngle) * barrelLen - fbW / 2;
            const spawnY = pivotY + Math.sin(enemy.barrelAngle) * barrelLen - fbH / 2;
            const speed = 300;
            const vx = Math.cos(enemy.barrelAngle) * speed;
            const vy = Math.sin(enemy.barrelAngle) * speed;
            // Fireballs carry hit points so lasers can shoot them down.
            fireballs.push({ x: spawnX, y: spawnY, w: fbW, h: fbH, vx: vx, vy: vy, hp: 5 });
            playSfx('fireballSfx', 0.8);
            // Reset tank firing cooldown to 3 seconds.
            enemy.fireCooldown = 3.0;
          }
        }
        if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
          // Determine if the player is above the enemy
          const playerBottom = player.y + player.h;
          const enemyThreshold = enemy.y + enemy.h * 0.5;
          if (playerBottom <= enemyThreshold) {
            // Player squishes enemy by landing on top
            enemy.health--;
            player.vy = jumpVel * 0.6;
            // Play squish sound
            playSfx('squish', 0.8);
            if (enemy.health <= 0) segment.enemies.splice(i, 1);
          } else {
            loseLife();
          }
        }
      }
    }

    if (boss) {
      boss.animTimer += dt;
      if (boss.hitFlash > 0) boss.hitFlash -= dt * 5;
      if (boss.x > player.x + 100) boss.x -= 40 * dt;
      else if (boss.x < player.x - 100) boss.x += 40 * dt;
      // Boss fireball attack. Fireballs now aim directly at the player rather than
      // travelling horizontally. Compute a normalized vector from the boss towards
      // the player's centre, then scale to a fixed speed.
      boss.fireCooldown -= dt;
      if (boss.fireCooldown <= 0) {
        const fbW = 40;
        const fbH = 40;
        // Spawn the fireball roughly from the boss's chest/centre.
        const spawnX = boss.x + boss.w * 0.5 - fbW * 0.5;
        const spawnY = boss.y + boss.h * 0.5 - fbH * 0.5;
        // Calculate direction to the player's centre.
        const playerCx = player.x + player.w * 0.5;
        const playerCy = player.y + player.h * 0.5;
        const fireballCx = spawnX + fbW * 0.5;
        const fireballCy = spawnY + fbH * 0.5;
        let dx = playerCx - fireballCx;
        let dy = playerCy - fireballCy;
        const len = Math.hypot(dx, dy) || 1.0;
        // Normalise and multiply by speed.
        const speed = 350;
        const vx = (dx / len) * speed;
        const vy = (dy / len) * speed;
        // Each fireball has a small amount of health so the player can shoot it down with lasers.
        fireballs.push({ x: spawnX, y: spawnY, w: fbW, h: fbH, vx: vx, vy: vy, hp: 5 });
        playSfx('fireballSfx', 0.8);
        // Reset cooldown; bosses now fire twice as often as the previously reduced rate.
        boss.fireCooldown = (2.0 / 0.3) / 2;
      }
      if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, boss.x, boss.y, boss.w, boss.h)) loseLife();
    }

    // Update fireballs
    for (let fi = fireballs.length - 1; fi >= 0; fi--) {
      const fb = fireballs[fi];
      fb.x += fb.vx * dt;
      fb.y += fb.vy * dt;
      if (fb.x < camera.x - 100 || fb.x > camera.x + canvas.width + 100 || fb.y > canvas.height + 100 || fb.y + fb.h < -100) {
        fireballs.splice(fi, 1);
        continue;
      }
      if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, fb.x, fb.y, fb.w, fb.h)) {
        loseLife();
        fireballs.splice(fi, 1);
        continue;
      }
    }

    for (const segment of segments) {
      for (let i = segment.coins.length - 1; i >= 0; i--) {
        const c = segment.coins[i];
        c.sparkleT += dt * 8;
        if (rectsOverlap(player.x, player.y, player.w, player.h, c.x - c.size/2, c.y - c.size/2, c.size * 2, c.size * 2)) {
          segment.coins.splice(i, 1);
          player.sessionCoins++; score += 10;
          // Track coins towards extra life. Every 127 coins collected awards an extra life.
          coinsForExtraLife++;
          // When enough coins have been collected, grant the corresponding number of extra lives.
          if (coinsForExtraLife >= 127) {
            const livesToAdd = Math.floor(coinsForExtraLife / 127);
            coinsForExtraLife = coinsForExtraLife % 127;
            player.lives += livesToAdd;
            player.maxLives = Math.max(player.maxLives, player.lives);
            // Show damage number to indicate extra life gained. Use pluralised value if multiple.
            createDamageNumber(c.x, c.y, `+${livesToAdd} LIFE`, '#f00');
            playSfx('life', 0.8);
          }
          createParticle(c.x, c.y, '#FFD700', 5, 8);
          // Play coin collection sound
          playSfx('coinCollect', 0.7);
        }
      }
      for (let i = segment.powerups.length - 1; i >= 0; i--) {
        const p = segment.powerups[i];
        if (rectsOverlap(player.x, player.y, player.w, player.h, p.x, p.y, p.w, p.h)) {
          segment.powerups.splice(i, 1);
          // Grant an extra life whenever a heart power-up is collected, regardless of the current number
          // of lives. Also update maxLives to reflect the new maximum so the value stays in sync.
          player.lives++;
          player.maxLives = Math.max(player.maxLives, player.lives);
          createDamageNumber(p.x, p.y, '+1 LIFE', '#f00');
          // Play extra life sound
          playSfx('life', 0.8);
        }
      }
    }
  }

  // ============ DRAWING ============
  function draw() {
    ctx.save();
    ctx.translate(shake.x, shake.y);

    // Parallax BG - choose background based on current level. If a specific
    // background asset for the level exists and is loaded, use it; otherwise
    // fall back to the default bg.
    let bgAsset = assets.bg;
    const bgKey = 'bg' + currentLevel;
    if (assets[bgKey] && assets[bgKey].complete && assets[bgKey].naturalWidth > 0) {
      bgAsset = assets[bgKey];
    }
    if (bgAsset && bgAsset.width > 0) {
      const bgW = bgAsset.width;
      const bgH = bgAsset.height;
      const scale = canvas.height / bgH;
      const scaledW = bgW * scale;
      const scaledH = canvas.height;
      const totalScroll = camera.x * 0.2;
      const offset = totalScroll % scaledW;
      ctx.drawImage(bgAsset, -offset, 0, scaledW, scaledH);
      ctx.drawImage(bgAsset, -offset + scaledW, 0, scaledW, scaledH);
    } else {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // Platforms
    for (const segment of segments) {
      for (const plat of segment.platforms) {
        if (plat.type === 'ground') {
          if (assets.ground && assets.ground.width > 0) {
            const pat = ctx.createPattern(assets.ground, 'repeat');
            if (pat) {
              ctx.fillStyle = pat; ctx.save(); ctx.translate(plat.x, plat.y); ctx.fillRect(0, 0, plat.w, plat.h); ctx.restore();
            } else {
              ctx.fillStyle = '#333'; ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
            }
          } else {
            ctx.fillStyle = '#333'; ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
          }
        } else {
          if (assets.platform && assets.platform.width > 0) ctx.drawImage(assets.platform, plat.x, plat.y, plat.w, plat.h);
          else { ctx.fillStyle = '#555'; ctx.fillRect(plat.x, plat.y, plat.w, plat.h); }
        }
      }
    }

    // Coins & Hearts
    for (const segment of segments) {
      if (assets.coin && assets.coin.complete && assets.coin.naturalWidth > 0) {
        for (const c of segment.coins) {
          const pulse = 1.0 + Math.sin(c.sparkleT) * 0.1;
          const w = (c.size * 2) * pulse;
          const h = (c.size * 2) * pulse;
          ctx.drawImage(assets.coin, c.x - w/2, c.y - h/2, w, h);
        }
      }
      if (assets.heart && assets.heart.complete && assets.heart.naturalWidth > 0) {
        for (const p of segment.powerups) {
          const pulse = 1.0 + Math.sin(time * 5) * 0.1;
          const w = p.w * pulse;
          const h = p.h * pulse;
          const centerX = p.x + p.w/2;
          const centerY = p.y + p.h/2;
          ctx.drawImage(assets.heart, centerX - w/2, centerY - h/2, w, h);
        }
      }
    }

    // Flag
    if (levelFlag) {
      ctx.fillStyle = '#fff'; ctx.fillRect(levelFlag.x, levelFlag.y, 5, levelFlag.h);
      ctx.fillStyle = '#FFD700'; ctx.fillRect(levelFlag.x+5, levelFlag.y, 40, 30);
    }

    // Enemies
    for (const segment of segments) {
      for (const enemy of segment.enemies) {
        ctx.save();
        ctx.translate(enemy.x + enemy.w/2, enemy.y + enemy.h/2);
        if (enemy.type === 'hopper') {
          // Flip the hopper's sprite so it always faces the direction of movement.
          // We use -enemy.dir here so that a positive dir (moving right) flips the sprite
          // horizontally and positions the eyes and toes correctly.
          ctx.scale(-enemy.dir, 1);
          if (assets.hopper && assets.hopper.complete && assets.hopper.naturalWidth > 0) {
            // Draw sprite asset
            ctx.drawImage(assets.hopper, -enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
          } else {
            // Draw body
            ctx.fillStyle = '#FF9900';
            ctx.fillRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
            // Draw eyes on the front side of the hopper (moving forward). Because we flipped the
            // context horizontally with -enemy.dir, the eyeX must be negative so that after
            // scaling it appears on the positive (forward) side.
            const eyeRadius = enemy.w * 0.05;
            const eyeX = -enemy.w * 0.35;
            const eyeY1 = -enemy.h * 0.25;
            const eyeY2 = -enemy.h * 0.05;
            // Outer white circles
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath(); ctx.arc(eyeX, eyeY1, eyeRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX, eyeY2, eyeRadius, 0, Math.PI * 2); ctx.fill();
            // Pupils
            const pupilRadius = eyeRadius * 0.4;
            ctx.fillStyle = '#000000';
            ctx.beginPath(); ctx.arc(eyeX, eyeY1, pupilRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX, eyeY2, pupilRadius, 0, Math.PI * 2); ctx.fill();
            // Draw feet with toes pointing up when the hopper is moving upward (vy < 0) and pointing
            // down when descending or on the ground. Each foot is a simple triangle attached to the
            // bottom of the body.
            const footW = enemy.w * 0.25;
            const footH = enemy.h * 0.18;
            const baseY = enemy.h / 2;
            const pointingUp = enemy.vy < 0;
            // Positions for two feet relative to the centre
            const footPositions = [-enemy.w * 0.25, enemy.w * 0.25];
            ctx.fillStyle = '#FF9900';
            for (const fx of footPositions) {
              ctx.beginPath();
              if (pointingUp) {
                // Apex above the base for upward motion
                ctx.moveTo(fx, baseY);
                ctx.lineTo(fx - footW / 2, baseY - footH);
                ctx.lineTo(fx + footW / 2, baseY - footH);
              } else {
                // Apex below the base for downward motion or standing
                ctx.moveTo(fx, baseY);
                ctx.lineTo(fx - footW / 2, baseY + footH);
                ctx.lineTo(fx + footW / 2, baseY + footH);
              }
              ctx.closePath();
              ctx.fill();
            }
          }
        } else if (enemy.type === 'flyer') {
          // Flip sprite orientation similar to walkers so they face the direction of travel.
          ctx.scale(-enemy.dir, 1);
          // Draw flapping wings using vector graphics. The wings flap up and down based on
          // the flyer‚Äôs animation timer.
          const wingW = enemy.w * 0.6;
          const wingH = enemy.h * 0.5;
          const flap = Math.sin(enemy.animTimer * 8) * (enemy.h * 0.2);
          // Left wing
          ctx.fillStyle = '#99CCFF';
          ctx.beginPath();
          const wingBaseY = -enemy.h * 0.1;
          ctx.moveTo(-enemy.w / 2, wingBaseY);
          ctx.lineTo(-enemy.w / 2 - wingW, wingBaseY - wingH / 2 + flap);
          ctx.lineTo(-enemy.w / 2 - wingW, wingBaseY + wingH / 2 + flap);
          ctx.closePath();
          ctx.fill();
          // Right wing (mirror image)
          ctx.beginPath();
          ctx.moveTo(enemy.w / 2, wingBaseY);
          ctx.lineTo(enemy.w / 2 + wingW, wingBaseY - wingH / 2 + flap);
          ctx.lineTo(enemy.w / 2 + wingW, wingBaseY + wingH / 2 + flap);
          ctx.closePath();
          ctx.fill();
          // Draw the flyer itself (sprite or fallback) on top of wings
          if (assets.flyer && assets.flyer.complete && assets.flyer.naturalWidth > 0) {
            ctx.drawImage(assets.flyer, -enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
          } else {
            ctx.fillStyle = '#99CCFF';
            ctx.fillRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
          }
        } else if (enemy.type === 'tank') {
          // Draw tank body (image or fallback)
          if (assets.tank && assets.tank.complete && assets.tank.naturalWidth > 0) {
            ctx.drawImage(assets.tank, -enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
          } else {
            ctx.fillStyle = '#4d4d4d';
            ctx.fillRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);
          }
          // Draw the tank's barrel as a rotated rectangle. The pivot is 40% down from
          // the top of the tank relative to its centre.
          ctx.save();
          const localPivotY = -enemy.h / 2 + enemy.h * 0.4;
          ctx.translate(0, localPivotY);
          ctx.rotate(enemy.barrelAngle);
          const barrelLen = enemy.w * 0.6;
          const barrelH = enemy.h * 0.1;
          ctx.fillStyle = '#333';
          ctx.fillRect(0, -barrelH / 2, barrelLen, barrelH);
          ctx.restore();
        } else if (enemy.type === 'walker') {
          ctx.rotate(enemy.rotateAngle);
          ctx.fillStyle = '#a890d0'; ctx.beginPath(); ctx.arc(0,0,enemy.w/2, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(enemy.w/2, 0); ctx.stroke();
        }
        ctx.restore();
      }
    }

    // Boss
    if (boss) {
      // Draw a soft glow behind the boss. The colour gradually shifts from green
      // (full health) to red (low health) as the boss takes damage.
      const ratio = boss.maxHealth > 0 ? boss.health / boss.maxHealth : 0;
      const rVal = Math.floor(255 * (1.0 - ratio));
      const gVal = Math.floor(255 * ratio);
      const colourStart = `rgba(${rVal},${gVal},0,0.6)`;
      const colourEnd = `rgba(${rVal},${gVal},0,0)`;
      const cx = boss.x + boss.w * 0.5;
      const cy = boss.y + boss.h * 0.5;
      const maxR = Math.max(boss.w, boss.h) * 0.7;
      ctx.save();
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
      gradient.addColorStop(0, colourStart);
      gradient.addColorStop(1, colourEnd);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.ellipse(cx, cy, boss.w * 0.7, boss.h * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Draw the boss sprite (or fallback rectangle). Apply hit-flash transparency if necessary.
      ctx.save();
      if (boss.hitFlash > 0) ctx.globalAlpha = 0.5 + Math.sin(time * 50) * 0.5;
      let imgKey = boss.bossType;
      if (boss.variation !== 'plain' && boss.bossType !== 'chimiera') imgKey += '_' + boss.variation;
      if (assets[imgKey] && assets[imgKey].complete && assets[imgKey].naturalWidth > 0) {
        ctx.drawImage(assets[imgKey], boss.x, boss.y, boss.w, boss.h);
      } else {
        ctx.fillStyle = 'red';
        ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
      }
      ctx.restore();
      // HP bar
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(boss.x, boss.y - 20, boss.w, 10);
      ctx.fillStyle = 'red';
      ctx.fillRect(boss.x + 1, boss.y - 19, (boss.w - 2) * (boss.health / boss.maxHealth), 8);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 2;
      ctx.fillText(boss.name, boss.x + boss.w / 2, boss.y - 25);
      ctx.shadowBlur = 0;
    }

    // Lasers
    for (const laser of lasers) {
      ctx.fillStyle = '#7be2ff'; ctx.fillRect(laser.x, laser.y, laser.w, laser.h);
    }

    // Fireballs
    for (const fb of fireballs) {
      // Always use the fireball image if available. Fall back to a coloured rectangle if not.
      if (assets.fireball) {
        ctx.drawImage(assets.fireball, fb.x, fb.y, fb.w, fb.h);
      } else {
        ctx.fillStyle = '#ff4500';
        ctx.fillRect(fb.x, fb.y, fb.w, fb.h);
      }
    }

    // Player
    ctx.save();
    ctx.translate(player.x, player.y);
    if (player.invincible) ctx.globalAlpha = 0.5 + Math.sin(time*20)*0.4;
    ctx.save();
    ctx.translate(player.w/2, 0); ctx.scale(player.facing, 1); ctx.translate(-player.w/2, 0);
    if (assets.player && assets.player.complete && assets.player.naturalWidth > 0) ctx.drawImage(assets.player, 0, 0, player.w, player.h);
    else { ctx.fillStyle = '#ccc'; ctx.fillRect(0, 0, player.w, player.h); }
    ctx.restore();
    ctx.restore();

    // Particles & Damage numbers
    for (const p of particles) { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); }
    ctx.globalAlpha = 1;
    for (const dn of damageNumbers) {
      ctx.globalAlpha = dn.life; ctx.fillStyle = dn.color; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center';
      ctx.shadowColor = '#000'; ctx.shadowBlur = 2; ctx.fillText(dn.value, dn.x, dn.y);
    }
    ctx.globalAlpha = 1; ctx.shadowBlur = 0;

    ctx.restore();

    // Overlays
    if (gameState === 'bossIntro') {
      ctx.fillStyle = 'rgba(0,0,0, 0.3)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font = 'bold 80px sans-serif'; ctx.textAlign = 'center'; ctx.fillStyle = 'red';
      ctx.shadowColor = '#000'; ctx.shadowBlur = 10; ctx.fillText('Boss Approaching', canvas.width/2, canvas.height/2); ctx.shadowBlur = 0;
    }
    if (gameState === 'levelComplete') {
      ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#FFD700'; ctx.font = 'bold 50px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('LEVEL COMPLETE!', canvas.width/2, canvas.height/2 - 20);
      ctx.font = '20px sans-serif'; ctx.fillText('Press ENTER or TAP to continue', canvas.width/2, canvas.height/2 + 40);
    } else if (gameState === 'gameOver') {
      ctx.fillStyle = 'rgba(0,0,0,0.9)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f00'; ctx.font = 'bold 50px sans-serif'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
      ctx.fillStyle = '#fff'; ctx.font = '20px sans-serif'; ctx.fillText('Press R or TAP to Restart', canvas.width/2, canvas.height/2 + 40);
    }
  }

  // ============ DRAW START SCREEN BUNNY ============
  window.drawStartScreenBunny = function() {
    const sCanvas = document.getElementById('start-bunny-canvas');
    if (!sCanvas || !assets.player) return;
    if (!assets.player.complete || assets.player.naturalWidth === 0) { setTimeout(drawStartScreenBunny, 100); return; }
    const sCtx = sCanvas.getContext('2d');
    sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);
    const img = assets.player;
    const x = (sCanvas.width - img.naturalWidth) / 2;
    const y = (sCanvas.height - img.naturalHeight) / 2;
    sCtx.drawImage(img, x, y);
  };

  // ============ INPUT ============
  window.addEventListener('keydown', e => {
    if (['Space','ArrowUp','ArrowLeft','ArrowRight','Enter','KeyR','KeyX','Escape'].includes(e.code)) e.preventDefault();
    if (gameState === 'levelComplete' && e.code === 'Enter') startNextLevel();
    if (gameState === 'gameOver' && e.code === 'KeyR') location.reload();
    keys[e.code] = true;
    if (e.code === 'KeyX') wantShoot = true;
    if (e.code === 'Escape') paused = !paused;
  });
  window.addEventListener('keyup', e => { keys[e.code] = false; });

  const btns = {
    left: document.getElementById('mobile-left'),
    right: document.getElementById('mobile-right'),
    jump: document.getElementById('mobile-jump'),
    shoot: document.getElementById('mobile-shoot')
  };
  const bindTouch = (btn, code) => {
    if (!btn) return;
    btn.addEventListener('touchstart', e => { e.preventDefault(); keys[code]=true; if(code==='KeyX') wantShoot=true; }, { passive: false });
    btn.addEventListener('touchend', e => { e.preventDefault(); keys[code]=false; }, { passive: false });
    btn.addEventListener('touchcancel', e => { e.preventDefault(); keys[code]=false; }, { passive: false });
  };
  bindTouch(btns.left, 'ArrowLeft'); bindTouch(btns.right, 'ArrowRight');
  bindTouch(btns.jump, 'Space'); bindTouch(btns.shoot, 'KeyX');

  // Start Game Logic
  function startGame() {
    if (gameStarted) return;
    // Unlock audio on first user gesture
    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { /* ignore */ }
    }
    gameStarted = true;
    document.getElementById('start-screen').classList.add('hidden');
    gameState = 'playing';
    playMusic(`level${currentLevel}`);

    // --- automated test hook ---
    // Test hopper spawn logic moved to initialization to ensure segments exist.
  }

  // Handle click on start button AND canvas
  document.getElementById('start-btn').addEventListener('click', startGame);
  canvas.addEventListener('click', () => {
    if (!gameStarted && gameReady) { startGame(); return; }
    if (gameState === 'levelComplete') startNextLevel();
    if (gameState === 'gameOver') location.reload();
  });

  // Prevent scrolling while playing on mobile
  document.body.addEventListener('touchmove', e => { if (gameStarted) e.preventDefault(); }, { passive: false });

  // Loop
  let last = performance.now();
  function frame(now) {
    const dt = Math.min(1/30, (now - last)/1000);
    last = now;
    if (gameStarted) update(dt);
    draw();
    requestAnimationFrame(frame);
  }

  // INITIALIZE
  loadAssets();
  fit();
  for (let i = 0; i < 3; i++) loadNextSegment();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
