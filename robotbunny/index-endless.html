<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Robot Bunny Platformer ‚Äî Moon Edition (Endless)</title>
<style>
  :root {
    --bg-deep: #000000;
    --bg-halo: #0a0f18;
  }
  html, body { height: 100%; margin: 0; background: var(--bg-deep); color: #e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow: hidden; }
  #wrap { display: grid; place-items: center; height: 100%; }
  canvas {
    background: radial-gradient(1000px 600px at 50% -200px, var(--bg-halo), var(--bg-deep) 55%);
    width: min(100vw, 960px);
    height: min(62vh, 560px);
    border-radius: 12px;
    box-shadow: 0 12px 36px rgba(0,0,0,.45), inset 0 0 80px rgba(123,226,255,0.03);
  }
  .hud {
    position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
    font-weight: 650; letter-spacing: .2px; text-shadow: 0 0 8px rgba(123,226,255,.15);
    font-size: 13px; max-width: 90vw;
  }
  .hud-item { display: flex; align-items: center; gap: 5px; padding: 3px 8px; background: rgba(16,22,32,0.85); border-radius: 5px; border: 1px solid rgba(123,226,255,0.25); }
  .xp-bar {
    position: fixed; top: 55px; left: 50%; transform: translateX(-50%);
    width: min(350px, 75vw); height: 18px;
    background: rgba(16,22,32,0.85); border-radius: 9px;
    border: 1px solid rgba(123,226,255,0.3);
    overflow: hidden;
  }
  .xp-fill {
    height: 100%; background: linear-gradient(90deg, #7be2ff, #5bc0de);
    transition: width 0.3s ease;
    border-radius: 9px;
  }
  .xp-text {
    position: absolute; width: 100%; text-align: center;
    line-height: 18px; font-size: 10px; font-weight: 700;
    color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.8);
  }
  .hint { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); opacity: .8; font-size: 12px; color: #9fb1cc; text-align: center; max-width: 90vw; }
  .badge { position: fixed; top: 10px; right: 14px; font-size: 11px; color: #9fb1cc; opacity: .8; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="560" aria-label="Robot Bunny Platformer ‚Äî Moon Edition"></canvas>
</div>
<div class="hud">
  <div class="hud-item"><span>üéÆ</span><span id="level">Lv.1</span></div>
  <div class="hud-item"><span>‚ù§Ô∏è</span><span id="lives">√ó3</span></div>
  <div class="hud-item"><span>‚ö°</span><span id="threat">TL:0</span></div>
  <div class="hud-item"><span>üìè</span><span id="distance">0m</span></div>
  <div class="hud-item"><span>üéØ</span><span id="score">0</span></div>
  <div class="hud-item"><span>ü™ô</span><span id="coins">0</span></div>
</div>
<div class="xp-bar">
  <div class="xp-fill" id="xp-fill" style="width: 0%"></div>
  <div class="xp-text" id="xp-text">XP: 0 / 100</div>
</div>
<div class="hint" id="hint-text">Move: ‚Üê‚Üí ‚Ä¢ Jump: Space/‚Üë ‚Ä¢ Shoot: X ‚Ä¢ Pause: ESC ‚Ä¢ Restart: R</div>
<div class="badge">Endless Edition v2.0</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Mobile detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0);

  function fit() {
    const maxW = Math.min(window.innerWidth, 960);
    const availableHeight = window.innerHeight * 0.62;
    const maxH = Math.min(availableHeight, 560);
    const ar = canvas.width / canvas.height;
    let w = maxW, h = w / ar;
    if (h > maxH) { h = maxH; w = h * ar; }
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', fit); fit();

  // Utility functions
  function rand(a, b) { return a + Math.random() * (b - a); }
  function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rectsOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
    return !(x1 + w1 < x2 || x1 > x2 + w2 || y1 + h1 < y2 || y1 > y2 + h2);
  }
  function roundRect(x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Constants
  const GROUND_Y = canvas.height - 80;
  const gravity = 2200;
  const jumpVel = -950;
  const moveSpeed = 250;
  const maxVelX = 350;

  // Game state
  let time = 0;
  let score = 0;
  let gameOver = false;
  let paused = false;
  let camera = { x: 0, y: 0 };
  let shake = { x: 0, y: 0, intensity: 0 };

  // Threat system
  let threatLevel = 0;
  let segmentsCompleted = 0;
  let distance = 0;

  // Meta progression
  let xp = parseInt(localStorage.getItem('rb_endless_xp') || '0');
  let playerLevel = parseInt(localStorage.getItem('rb_endless_level') || '1');
  let coins = parseInt(localStorage.getItem('rb_endless_coins') || '0');
  let sessionCoins = 0;
  let xpForNextLevel = 100 * Math.pow(playerLevel, 1.5);

  // Player
  const player = {
    x: 100, y: GROUND_Y - 72, w: 48, h: 64,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1,
    shootCooldown: 0,
    invincible: false,
    invincibleTimer: 0,
    lives: 3,
    animState: 'idle',
    animFrame: 0,
    animTimer: 0
  };

  // Input
  const keys = {};
  let wantShoot = false;

  // Entities
  const lasers = [];
  const particles = [];
  const segments = [];
  let currentSegmentIndex = 0;
  let nextSegmentX = 0;

  // Background
  const bgLayers = [
    { elements: [], speed: 0.1, color: '#0a0f18' },
    { elements: [], speed: 0.3, color: '#1a2530' },
    { elements: [], speed: 0.5, color: '#2a3540' }
  ];

  // Audio
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();
  let soundEnabled = true;
  let musicNodes = [];
  let musicPlaying = false;

  // Simple music system
  const musicTracks = [
    {
      tempo: 500,
      melody: [
        { note: 392, duration: 0.3 }, { note: 440, duration: 0.3 },
        { note: 494, duration: 0.3 }, { note: 523, duration: 0.3 },
        { note: 494, duration: 0.3 }, { note: 440, duration: 0.3 },
        { note: 392, duration: 0.6 }, { note: 330, duration: 0.6 }
      ],
      bass: [330, 392, 294, 349]
    }
  ];

  function startMusic() {
    stopMusic();
    if (!soundEnabled) return;
    musicPlaying = true;

    const track = musicTracks[0];
    let melodyIndex = 0;
    let bassIndex = 0;

    function playMelodyNote() {
      if (!musicPlaying || !soundEnabled) return;

      const noteData = track.melody[melodyIndex % track.melody.length];
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.value = noteData.note * (1 + threatLevel * 0.02);
      gain.gain.value = 0.04;

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.04, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + noteData.duration);

      osc.start(now);
      osc.stop(now + noteData.duration);

      musicNodes.push(osc);
      melodyIndex++;

      setTimeout(playMelodyNote, noteData.duration * 1000 * (1 - threatLevel * 0.01));
    }

    function playBassNote() {
      if (!musicPlaying || !soundEnabled) return;

      const note = track.bass[bassIndex % track.bass.length];
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'triangle';
      osc.frequency.value = note;
      gain.gain.value = 0.03;

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      const duration = track.tempo / 1000;
      osc.start(now);
      osc.stop(now + duration);

      musicNodes.push(osc);
      bassIndex++;

      setTimeout(playBassNote, track.tempo);
    }

    playMelodyNote();
    playBassNote();
  }

  function stopMusic() {
    musicPlaying = false;
    for (const node of musicNodes) {
      try { node.stop(); } catch(e) {}
    }
    musicNodes = [];
  }

  function playSound(type) {
    if (!soundEnabled) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    switch(type) {
      case 'jump':
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
      case 'shoot':
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now); osc.stop(now + 0.08);
        break;
      case 'coin':
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
        break;
      case 'hit':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
        break;
      case 'stomp':
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
    }
  }

  function createParticle(x, y, color, count = 8) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + rand(-0.3, 0.3);
      const speed = rand(100, 250);
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - rand(50, 150),
        life: 1.0,
        decay: rand(1.5, 2.5),
        size: rand(3, 7),
        color
      });
    }
  }

  function gainXP(amount) {
    xp += amount;
    while (xp >= xpForNextLevel) {
      playerLevel++;
      xp -= xpForNextLevel;
      xpForNextLevel = Math.floor(100 * Math.pow(playerLevel, 1.5));
      coins += 10 * playerLevel;
      playSound('coin');
    }
    localStorage.setItem('rb_endless_xp', xp);
    localStorage.setItem('rb_endless_level', playerLevel);
    localStorage.setItem('rb_endless_coins', coins);
  }

  // Initialize background
  function initBackground() {
    for (const layer of bgLayers) {
      layer.elements = [];
      const count = layer.speed < 0.3 ? 80 : (layer.speed < 0.5 ? 50 : 30);
      for (let i = 0; i < count; i++) {
        layer.elements.push({
          x: rand(0, 4000),
          y: rand(0, GROUND_Y - 50),
          size: layer.speed < 0.3 ? rand(1, 2) : (layer.speed < 0.5 ? rand(2, 3) : rand(3, 4)),
          twinkle: rand(0, Math.PI * 2),
          twinkleSpeed: rand(1, 3)
        });
      }
    }
  }

  // Generate segment
  function generateSegment(seed) {
    const width = randInt(1600, 2200);
    const segment = {
      id: seed,
      startX: nextSegmentX,
      width: width,
      platforms: [],
      enemies: [],
      coins: []
    };

    // Ground platform
    segment.platforms.push({
      x: segment.startX,
      y: GROUND_Y + 40,
      w: width,
      h: 200,
      type: 'ground'
    });

    // Generate platforms
    const gapMax = 200 + threatLevel * 10;
    const platformCount = Math.floor(width / 250);

    let currentX = segment.startX + 150;
    let currentY = GROUND_Y - 100;

    for (let i = 0; i < platformCount; i++) {
      const gap = rand(80, gapMax);
      const dy = rand(-80 - threatLevel * 2, 80 + threatLevel * 2);
      const platformW = randInt(80, 150);

      currentX += gap;
      currentY += dy;
      currentY = clamp(currentY, GROUND_Y - 380, GROUND_Y - 80);

      segment.platforms.push({
        x: currentX,
        y: currentY,
        w: platformW,
        h: 20,
        type: 'platform'
      });

      // Spawn enemies on platforms
      if (Math.random() < 0.4 + threatLevel * 0.02) {
        const enemyTypes = ['hopper', 'walker', 'flyer'];
        const type = enemyTypes[randInt(0, threatLevel > 5 ? 2 : 1)];
        const enemy = {
          type: type,
          x: currentX + rand(10, platformW - 50),
          y: currentY - (type === 'flyer' ? 80 : 30),
          w: type === 'flyer' ? 45 : (type === 'walker' ? 35 : 40),
          h: type === 'flyer' ? 25 : 30,
          vx: (type === 'walker' ? 80 : (type === 'flyer' ? 100 : 50)) * (1 + threatLevel * 0.03),
          vy: 0,
          health: 1 + Math.floor(threatLevel / 6),
          dir: Math.random() > 0.5 ? 1 : -1,
          animTimer: 0,
          rotateAngle: 0,
          bobT: rand(0, Math.PI * 2),
          flapTimer: 0,
          jumpTimer: type === 'hopper' ? rand(1, 3) : 0
        };
        segment.enemies.push(enemy);
      }

      // Add coins
      if (Math.random() < 0.5) {
        for (let c = 0; c < randInt(1, 3); c++) {
          segment.coins.push({
            x: currentX + rand(20, platformW - 40),
            y: currentY - rand(30, 80),
            size: 14,
            sparkleT: rand(0, Math.PI * 2)
          });
        }
      }

      currentX += platformW;
    }

    return segment;
  }

  function loadNextSegment() {
    const segment = generateSegment(currentSegmentIndex);
    segments.push(segment);
    nextSegmentX += segment.width;
    currentSegmentIndex++;
    segmentsCompleted++;
    threatLevel += 0.3;
    gainXP(100); // XP for completing segment
  }

  function unloadOldSegments() {
    while (segments.length > 0 && segments[0].startX + segments[0].width < camera.x - 500) {
      segments.shift();
    }
  }

  function getAllEnemies() {
    const enemies = [];
    for (const segment of segments) {
      enemies.push(...segment.enemies);
    }
    return enemies;
  }

  function getAllCoins() {
    const coins = [];
    for (const segment of segments) {
      coins.push(...segment.coins);
    }
    return coins;
  }

  function getAllPlatforms() {
    const platforms = [];
    for (const segment of segments) {
      platforms.push(...segment.platforms);
    }
    return platforms;
  }

  // Load initial segments
  for (let i = 0; i < 3; i++) {
    loadNextSegment();
  }

  // Input handlers
  window.addEventListener('keydown', (e) => {
    if (['Space','ArrowUp','ArrowLeft','ArrowRight','Escape','KeyP','KeyM','KeyX','KeyR'].includes(e.code)) e.preventDefault();

    if (e.code === 'Escape' || e.code === 'KeyP') {
      if (!gameOver) {
        paused = !paused;
        if (paused) stopMusic();
        else startMusic();
      }
      return;
    }

    if (e.code === 'KeyM') {
      soundEnabled = !soundEnabled;
      if (!soundEnabled) stopMusic();
      else if (!paused && !gameOver) startMusic();
      return;
    }

    if (e.code === 'KeyR' && gameOver) {
      location.reload();
      return;
    }

    if (gameOver || paused) return;

    keys[e.code] = true;
    if (e.code === 'KeyX') wantShoot = true;
  });

  window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });

  function loseLife() {
    player.lives--;

    if (player.lives <= 0) {
      gameOver = true;
      coins += sessionCoins;
      localStorage.setItem('rb_endless_coins', coins);
      stopMusic();
      playSound('hit');
      shake.intensity = 20;
      createParticle(player.x + player.w / 2, player.y + player.h / 2, '#ff5555', 20);
    } else {
      player.x = camera.x + 100;
      player.y = GROUND_Y - player.h - 20;
      player.vx = 0;
      player.vy = 0;
      player.invincible = true;
      player.invincibleTimer = 2.0;
      playSound('hit');
      shake.intensity = 15;
    }
  }

  function updateHUD() {
    document.getElementById('level').textContent = `Lv.${playerLevel}`;
    document.getElementById('lives').textContent = `√ó${player.lives}`;
    document.getElementById('threat').textContent = `TL:${Math.floor(threatLevel)}`;
    document.getElementById('distance').textContent = `${Math.floor(distance / 10)}m`;
    document.getElementById('score').textContent = Math.floor(score);
    document.getElementById('coins').textContent = coins + sessionCoins;

    const xpPercent = (xp / xpForNextLevel * 100).toFixed(1);
    document.getElementById('xp-fill').style.width = `${xpPercent}%`;
    document.getElementById('xp-text').textContent = `XP: ${xp} / ${xpForNextLevel}`;
  }

  function update(dt) {
    if (gameOver || paused) return;

    time += dt;
    distance += Math.abs(player.vx) * dt;

    // Update player
    if (player.invincibleTimer > 0) {
      player.invincibleTimer -= dt;
      player.invincible = player.invincibleTimer > 0;
    }

    if (player.shootCooldown > 0) player.shootCooldown -= dt;

    // Player animation
    if (player.onGround) {
      if (Math.abs(player.vx) > 50) {
        player.animState = 'walk';
        player.animTimer += dt * Math.abs(player.vx) / 100;
        player.animFrame = player.animTimer % 1;
      } else {
        player.animState = 'idle';
        player.animFrame = 0;
      }
    } else {
      player.animState = 'jump';
    }

    // Movement
    const moveLeft = keys.ArrowLeft;
    const moveRight = keys.ArrowRight;
    const wantJump = keys.Space || keys.ArrowUp;

    if (moveLeft) {
      player.vx -= moveSpeed * dt * 8;
      player.facing = -1;
    }
    if (moveRight) {
      player.vx += moveSpeed * dt * 8;
      player.facing = 1;
    }

    if (!moveLeft && !moveRight) {
      player.vx *= 0.85;
    }

    player.vx = clamp(player.vx, -maxVelX, maxVelX);

    if (wantJump && player.onGround) {
      player.vy = jumpVel;
      player.onGround = false;
      playSound('jump');
      createParticle(player.x + player.w / 2, player.y + player.h, '#7be2ff', 6);
    }

    if (wantShoot && player.shootCooldown <= 0) {
      lasers.push({
        x: player.x + (player.facing > 0 ? player.w : 0),
        y: player.y + player.h / 2 - 2,
        w: 20, h: 4,
        vx: player.facing * 500,
        dir: player.facing
      });
      player.shootCooldown = 0.3;
      playSound('shoot');
      createParticle(player.x + player.w / 2, player.y + player.h / 2, player.facing > 0 ? '#ff3333' : '#3333ff', 4);
    }
    wantShoot = false;

    player.vy += gravity * dt;
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // Collision with platforms
    player.onGround = false;
    for (const plat of getAllPlatforms()) {
      if (rectsOverlap(player.x, player.y, player.w, player.h, plat.x, plat.y, plat.w, plat.h)) {
        if (player.vy > 0 && player.y + player.h - player.vy * dt < plat.y + 10) {
          player.y = plat.y - player.h;
          player.vy = 0;
          player.onGround = true;
        } else if (player.vy < 0 && player.y - player.vy * dt > plat.y + plat.h - 10) {
          player.y = plat.y + plat.h;
          player.vy = 0;
        }
      }
    }

    if (player.x < 0) player.x = 0;
    if (player.y > canvas.height + 100) loseLife();

    camera.x = player.x - canvas.width / 3;
    camera.x = Math.max(0, camera.x);

    // Load new segments
    if (player.x > nextSegmentX - canvas.width * 2) {
      loadNextSegment();
    }

    unloadOldSegments();

    // Update lasers
    for (let i = lasers.length - 1; i >= 0; i--) {
      const laser = lasers[i];
      laser.x += laser.vx * dt;

      if (laser.x < camera.x - 100 || laser.x > camera.x + canvas.width + 100) {
        lasers.splice(i, 1);
        continue;
      }

      for (const segment of segments) {
        for (let j = segment.enemies.length - 1; j >= 0; j--) {
          const enemy = segment.enemies[j];
          if (rectsOverlap(laser.x, laser.y, laser.w, laser.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
            enemy.health--;
            lasers.splice(i, 1);
            createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#ff5555', 10);
            playSound('stomp');
            score += 10;
            gainXP(50);
            if (enemy.health <= 0) {
              segment.enemies.splice(j, 1);
              score += 50;
            }
            break;
          }
        }
      }
    }

    // Update enemies
    for (const segment of segments) {
      for (let i = segment.enemies.length - 1; i >= 0; i--) {
        const enemy = segment.enemies[i];
        enemy.animTimer += dt;

        if (enemy.type === 'hopper') {
          enemy.jumpTimer -= dt;
          if (enemy.jumpTimer <= 0 && enemy.vy === 0) {
            enemy.vy = -600;
            enemy.jumpTimer = rand(1.5, 3.0);
          }
          enemy.vy += gravity * dt;
          enemy.y += enemy.vy * dt;
          enemy.x += enemy.dir * enemy.vx * dt;

          for (const plat of getAllPlatforms()) {
            if (rectsOverlap(enemy.x, enemy.y, enemy.w, enemy.h, plat.x, plat.y, plat.w, plat.h)) {
              if (enemy.vy > 0) {
                enemy.y = plat.y - enemy.h;
                enemy.vy = 0;
              }
            }
          }
        } else if (enemy.type === 'walker') {
          enemy.x += enemy.dir * enemy.vx * dt;
          enemy.rotateAngle += 0.15 * enemy.dir;

          if (enemy.x < segment.startX || enemy.x > segment.startX + segment.width) {
            enemy.dir *= -1;
          }
        } else if (enemy.type === 'flyer') {
          enemy.x += enemy.dir * enemy.vx * dt;
          enemy.bobT += 0.08;
          enemy.flapTimer += 0.2;

          if (enemy.x < camera.x - 50 || enemy.x > camera.x + canvas.width + 50) {
            enemy.dir *= -1;
          }
        }

        if (!player.invincible && rectsOverlap(player.x, player.y, player.w, player.h, enemy.x, enemy.y, enemy.w, enemy.h)) {
          if (player.vy > 0 && player.y + player.h * 0.6 < enemy.y + enemy.h / 2) {
            enemy.health--;
            player.vy = jumpVel * 0.6;
            createParticle(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, '#FFD700', 12);
            playSound('stomp');
            score += 100;
            gainXP(50);
            if (enemy.health <= 0) {
              segment.enemies.splice(i, 1);
            }
          } else {
            loseLife();
          }
        }
      }
    }

    // Update coins
    for (const segment of segments) {
      for (let i = segment.coins.length - 1; i >= 0; i--) {
        const coin = segment.coins[i];
        coin.sparkleT += dt * 8;

        if (rectsOverlap(player.x, player.y, player.w, player.h, coin.x - coin.size, coin.y - coin.size, coin.size * 2, coin.size * 2)) {
          segment.coins.splice(i, 1);
          sessionCoins++;
          score += 10;
          gainXP(10);
          createParticle(coin.x, coin.y, '#FFD700', 8);
          playSound('coin');
        }
      }
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += gravity * 0.5 * dt;
      p.life -= p.decay * dt;
      if (p.life <= 0) particles.splice(i, 1);
    }

    shake.intensity = Math.max(0, shake.intensity - dt * 10);
    shake.x = (Math.random() - 0.5) * shake.intensity;
    shake.y = (Math.random() - 0.5) * shake.intensity;

    updateHUD();
  }

  function draw() {
    ctx.save();
    ctx.translate(shake.x, shake.y);

    // Background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const layer of bgLayers) {
      for (const star of layer.elements) {
        const parallaxX = star.x - camera.x * layer.speed;

        if (parallaxX > -50 && parallaxX < canvas.width + 50) {
          star.twinkle += star.twinkleSpeed * 0.05;
          const alpha = 0.3 + Math.sin(star.twinkle) * 0.2;

          ctx.globalAlpha = alpha;
          ctx.fillStyle = layer.color;
          ctx.fillRect(parallaxX, star.y, star.size, star.size);
        }
      }
    }
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // Draw platforms
    for (const plat of getAllPlatforms()) {
      if (plat.type === 'ground') {
        ctx.fillStyle = '#2a313c';
        ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
        ctx.fillStyle = '#1b1f26';
        ctx.fillRect(plat.x, plat.y + 20, plat.w, plat.h - 20);
      } else {
        ctx.fillStyle = '#3a5570';
        ctx.strokeStyle = '#2a4050';
        ctx.lineWidth = 2;
        roundRect(plat.x, plat.y, plat.w, plat.h, 4, true, true);
      }
    }

    // Draw coins
    for (const coin of getAllCoins()) {
      ctx.save();
      ctx.translate(coin.x, coin.y);

      const pulse = 1 + Math.sin(coin.sparkleT) * 0.1;
      ctx.scale(pulse, pulse);

      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // Draw enemies
    for (const enemy of getAllEnemies()) {
      ctx.save();
      ctx.translate(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2);

      if (enemy.type === 'hopper') {
        const squish = enemy.vy !== 0 ? (enemy.vy > 0 ? 0.9 : 1.1) : (1 + Math.sin(enemy.animTimer) * 0.05);
        ctx.scale(1, squish);
        ctx.fillStyle = '#c9d0da';
        ctx.strokeStyle = '#8ea0b5';
        ctx.lineWidth = 2;
        roundRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h, 8, true, true);
      } else if (enemy.type === 'walker') {
        ctx.rotate(enemy.rotateAngle);
        ctx.fillStyle = '#a890d0';
        ctx.strokeStyle = '#7860a0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, enemy.w / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      } else if (enemy.type === 'flyer') {
        const wobble = Math.sin(enemy.bobT) * 3;
        ctx.translate(0, wobble);
        ctx.fillStyle = '#7895b8';
        ctx.strokeStyle = '#4a5f7a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, enemy.w / 2, enemy.h / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

      ctx.restore();
    }

    // Draw lasers
    for (const laser of lasers) {
      ctx.fillStyle = laser.dir > 0 ? '#ff3333' : '#3333ff';
      roundRect(laser.x, laser.y, laser.w, laser.h, 2, true, false);
    }

    // Draw player
    ctx.save();
    ctx.translate(player.x + player.w / 2, player.y + player.h / 2);

    if (player.invincible) {
      ctx.globalAlpha = 0.5 + Math.sin(time * 20) * 0.5;
    }

    ctx.scale(player.facing, 1);
    ctx.translate(-player.w / 2, -player.h / 2);

    let bodyOffset = 0;
    if (player.animState === 'walk') {
      bodyOffset = Math.sin(player.animFrame * Math.PI) * 2;
    }

    ctx.fillStyle = '#aeb7c4';
    ctx.strokeStyle = '#738096';
    ctx.lineWidth = 2;
    roundRect(4, 6 + bodyOffset, player.w - 8, player.h - 14, 10, true, true);

    ctx.fillStyle = '#8c97a7';
    roundRect(2, player.h - 12, player.w * 0.42, 12, 6, true, false);
    roundRect(player.w - player.w * 0.42 - 2, player.h - 12, player.w * 0.42, 12, 6, true, false);

    const earW = player.w * 0.2, earH = player.h * 0.7;
    ctx.fillStyle = '#aeb7c4';
    roundRect(player.w * 0.2, -earH * 0.4, earW, earH, 8, true, true);
    roundRect(player.w * 0.6, -earH * 0.3, earW, earH, 8, true, true);

    ctx.fillStyle = '#0d131a';
    roundRect(player.w * 0.25, player.h * 0.35 + bodyOffset, player.w * 0.5, player.h * 0.18, 8, true, false);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = '#7be2ff';
    roundRect(player.w * 0.3, player.h * 0.4 + bodyOffset, player.w * 0.4, player.h * 0.08, 5, true, false);
    ctx.globalCompositeOperation = 'source-over';

    ctx.globalAlpha = 1;
    ctx.restore();

    // Draw particles
    for (const p of particles) {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    }
    ctx.globalAlpha = 1;

    ctx.restore();
    ctx.restore();

    // Draw game over
    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#ff5555';
      ctx.font = 'bold 48px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);

      ctx.fillStyle = '#9fb1cc';
      ctx.font = '18px system-ui';
      ctx.fillText(`Distance: ${Math.floor(distance / 10)}m`, canvas.width / 2, canvas.height / 2);
      ctx.fillText(`Threat Level: ${Math.floor(threatLevel)}`, canvas.width / 2, canvas.height / 2 + 25);
      ctx.fillText(`Score: ${Math.floor(score)}`, canvas.width / 2, canvas.height / 2 + 50);

      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 20px system-ui';
      ctx.fillText('Press R to Restart', canvas.width / 2, canvas.height / 2 + 90);
    }

    // Draw pause
    if (paused && !gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#7be2ff';
      ctx.font = 'bold 48px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);

      ctx.fillStyle = '#9fb1cc';
      ctx.font = '16px system-ui';
      ctx.fillText('Press ESC or P to Resume', canvas.width / 2, canvas.height / 2 + 40);
    }
  }

  // Game loop
  let last = performance.now();
  function loop(now) {
    const rawDt = (now - last) / 1000;
    last = now;
    const dt = Math.min(1 / 30, rawDt);

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  initBackground();
  updateHUD();
  startMusic();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
